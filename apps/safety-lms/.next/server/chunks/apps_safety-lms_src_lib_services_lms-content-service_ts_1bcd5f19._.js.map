{"version":3,"sources":["turbopack:///[project]/apps/safety-lms/src/lib/db/queries/course-sections.ts","turbopack:///[project]/apps/safety-lms/src/lib/db/queries/content-blocks.ts","turbopack:///[project]/apps/safety-lms/src/lib/db/queries/quiz-questions.ts","turbopack:///[project]/apps/safety-lms/src/lib/db/queries/user-progress.ts","turbopack:///[project]/apps/safety-lms/src/lib/mappers/course-section-mappers.ts","turbopack:///[project]/apps/safety-lms/src/lib/mappers/content-block-mappers.ts","turbopack:///[project]/apps/safety-lms/src/lib/mappers/quiz-question-mappers.ts","turbopack:///[project]/apps/safety-lms/src/lib/mappers/user-progress-mappers.ts","turbopack:///[project]/apps/safety-lms/src/lib/services/lms-content-service.ts"],"sourcesContent":["import { eq, and, desc, asc, sql } from \"drizzle-orm\";\nimport { db } from \"../index\";\nimport {\n  courseSections,\n  courses,\n  contentBlocks,\n  quizQuestions,\n  CourseSection,\n  NewCourseSection,\n} from \"../schema\";\n\n/**\n * Course Section Query Operations\n * Handles database queries for course sections with proper access control\n */\n\n// =============================================================================\n// BASIC COURSE SECTION QUERIES\n// =============================================================================\n\n/**\n * Get course section by ID\n */\nexport const getCourseSectionById = async (\n  sectionId: string\n): Promise<CourseSection | null> => {\n  const result = await db\n    .select()\n    .from(courseSections)\n    .where(eq(courseSections.id, sectionId))\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get course section by course ID and section key\n */\nexport const getCourseSectionByKey = async (\n  courseId: string,\n  sectionKey: string\n): Promise<CourseSection | null> => {\n  const result = await db\n    .select()\n    .from(courseSections)\n    .where(\n      and(\n        eq(courseSections.courseId, courseId),\n        eq(courseSections.sectionKey, sectionKey)\n      )\n    )\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get all sections for a course\n */\nexport const getCourseSectionsByCourseId = async (\n  courseId: string,\n  options: {\n    includeUnpublished?: boolean;\n    sortBy?: \"orderIndex\" | \"title\" | \"createdAt\";\n    sortOrder?: \"asc\" | \"desc\";\n  } = {}\n): Promise<CourseSection[]> => {\n  const {\n    includeUnpublished = false,\n    sortBy = \"orderIndex\",\n    sortOrder = \"asc\",\n  } = options;\n\n  let whereClause = eq(courseSections.courseId, courseId);\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(courseSections.isPublished, true));\n  }\n\n  const orderBy =\n    sortOrder === \"desc\"\n      ? desc(courseSections[sortBy])\n      : asc(courseSections[sortBy]);\n\n  const result = await db\n    .select()\n    .from(courseSections)\n    .where(whereClause)\n    .orderBy(orderBy);\n\n  return result;\n};\n\n/**\n * Get course sections with content blocks and quiz questions\n */\nexport const getCourseSectionWithContent = async (\n  sectionId: string\n): Promise<{\n  section: CourseSection;\n  contentBlocks: any[];\n  quizQuestions: any[];\n} | null> => {\n  const section = await getCourseSectionById(sectionId);\n  if (!section) return null;\n\n  // Get content blocks\n  const blocks = await db\n    .select()\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId))\n    .orderBy(asc(contentBlocks.orderIndex));\n\n  // Get quiz questions\n  const questions = await db\n    .select()\n    .from(quizQuestions)\n    .where(eq(quizQuestions.sectionId, sectionId))\n    .orderBy(asc(quizQuestions.orderIndex));\n\n  return {\n    section,\n    contentBlocks: blocks,\n    quizQuestions: questions,\n  };\n};\n\n// =============================================================================\n// COURSE SECTION CREATION AND UPDATES\n// =============================================================================\n\n/**\n * Create a new course section\n */\nexport const createCourseSection = async (\n  sectionData: NewCourseSection\n): Promise<CourseSection> => {\n  const result = await db\n    .insert(courseSections)\n    .values(sectionData)\n    .returning();\n\n  return result[0];\n};\n\n/**\n * Update course section\n */\nexport const updateCourseSection = async (\n  sectionId: string,\n  updates: Partial<CourseSection>\n): Promise<CourseSection | null> => {\n  const result = await db\n    .update(courseSections)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(courseSections.id, sectionId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Delete course section\n */\nexport const deleteCourseSection = async (\n  sectionId: string\n): Promise<boolean> => {\n  const result = await db\n    .delete(courseSections)\n    .where(eq(courseSections.id, sectionId))\n    .returning();\n\n  return result.length > 0;\n};\n\n// =============================================================================\n// COURSE SECTION ORDERING OPERATIONS\n// =============================================================================\n\n/**\n * Update section order\n */\nexport const updateSectionOrder = async (\n  sectionId: string,\n  newOrderIndex: number\n): Promise<CourseSection | null> => {\n  const result = await db\n    .update(courseSections)\n    .set({\n      orderIndex: newOrderIndex,\n      updatedAt: new Date(),\n    })\n    .where(eq(courseSections.id, sectionId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Reorder multiple sections\n */\nexport const reorderSections = async (\n  courseId: string,\n  sectionOrders: Array<{ sectionId: string; orderIndex: number }>\n): Promise<CourseSection[]> => {\n  const results: CourseSection[] = [];\n\n  for (const order of sectionOrders) {\n    const result = await updateSectionOrder(order.sectionId, order.orderIndex);\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  return results;\n};\n\n/**\n * Get next available order index for a course\n */\nexport const getNextSectionOrderIndex = async (\n  courseId: string\n): Promise<number> => {\n  const result = await db\n    .select({ maxOrder: sql<number>`max(${courseSections.orderIndex})` })\n    .from(courseSections)\n    .where(eq(courseSections.courseId, courseId));\n\n  return (result[0]?.maxOrder || 0) + 1;\n};\n\n// =============================================================================\n// COURSE SECTION VALIDATION QUERIES\n// =============================================================================\n\n/**\n * Check if section key is unique within a course\n */\nexport const isSectionKeyUnique = async (\n  courseId: string,\n  sectionKey: string,\n  excludeSectionId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(courseSections.courseId, courseId),\n    eq(courseSections.sectionKey, sectionKey)\n  );\n\n  if (excludeSectionId) {\n    whereClause = and(\n      whereClause,\n      sql`${courseSections.id} != ${excludeSectionId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: courseSections.id })\n    .from(courseSections)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n/**\n * Check if order index is unique within a course\n */\nexport const isOrderIndexUnique = async (\n  courseId: string,\n  orderIndex: number,\n  excludeSectionId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(courseSections.courseId, courseId),\n    eq(courseSections.orderIndex, orderIndex)\n  );\n\n  if (excludeSectionId) {\n    whereClause = and(\n      whereClause,\n      sql`${courseSections.id} != ${excludeSectionId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: courseSections.id })\n    .from(courseSections)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n// =============================================================================\n// COURSE SECTION STATISTICS QUERIES\n// =============================================================================\n\n/**\n * Get section statistics\n */\nexport const getSectionStatistics = async (\n  sectionId: string\n): Promise<{\n  contentBlocksCount: number;\n  quizQuestionsCount: number;\n  publishedContentBlocks: number;\n  publishedQuizQuestions: number;\n} | null> => {\n  const section = await getCourseSectionById(sectionId);\n  if (!section) return null;\n\n  // Count content blocks\n  const contentBlocksResult = await db\n    .select({\n      total: sql<number>`count(*)`,\n      published: sql<number>`count(*) filter (where ${contentBlocks.sectionId} = ${sectionId})`,\n    })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId));\n\n  // Count quiz questions\n  const quizQuestionsResult = await db\n    .select({\n      total: sql<number>`count(*)`,\n      published: sql<number>`count(*) filter (where ${quizQuestions.isPublished} = true)`,\n    })\n    .from(quizQuestions)\n    .where(eq(quizQuestions.sectionId, sectionId));\n\n  return {\n    contentBlocksCount: contentBlocksResult[0]?.total || 0,\n    quizQuestionsCount: quizQuestionsResult[0]?.total || 0,\n    publishedContentBlocks: contentBlocksResult[0]?.published || 0,\n    publishedQuizQuestions: quizQuestionsResult[0]?.published || 0,\n  };\n};\n\n// =============================================================================\n// COURSE SECTION SEARCH QUERIES\n// =============================================================================\n\n/**\n * Search course sections\n */\nexport const searchCourseSections = async (\n  courseId: string,\n  searchTerm: string,\n  options: {\n    includeUnpublished?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<CourseSection[]> => {\n  const { includeUnpublished = false, limit = 20, offset = 0 } = options;\n\n  let whereClause = and(\n    eq(courseSections.courseId, courseId),\n    sql`${courseSections.title} ilike ${`%${searchTerm}%`}`\n  );\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(courseSections.isPublished, true));\n  }\n\n  const result = await db\n    .select()\n    .from(courseSections)\n    .where(whereClause)\n    .orderBy(asc(courseSections.orderIndex))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// COURSE SECTION ACCESS CONTROL QUERIES\n// =============================================================================\n\n/**\n * Get sections accessible to user based on role and course access\n */\nexport const getAccessibleCourseSections = async (\n  courseId: string,\n  userRole: string,\n  options: {\n    includeUnpublished?: boolean;\n  } = {}\n): Promise<CourseSection[]> => {\n  const { includeUnpublished = false } = options;\n\n  // Safety admins can access all sections\n  if (userRole === \"safety_admin\") {\n    return getCourseSectionsByCourseId(courseId, { includeUnpublished: true });\n  }\n\n  // Other roles can only access published sections unless explicitly allowed\n  return getCourseSectionsByCourseId(courseId, { includeUnpublished });\n};\n\n/**\n * Check if user can access a specific section\n */\nexport const canUserAccessSection = async (\n  sectionId: string,\n  userRole: string\n): Promise<boolean> => {\n  const section = await getCourseSectionById(sectionId);\n  if (!section) return false;\n\n  // Safety admins can access all sections\n  if (userRole === \"safety_admin\") return true;\n\n  // Other roles can only access published sections\n  return section.isPublished;\n};\n","import { eq, and, desc, asc, sql } from \"drizzle-orm\";\nimport { db } from \"../index\";\nimport {\n  contentBlocks,\n  courseSections,\n  ContentBlock,\n  NewContentBlock,\n  ContentBlockType,\n} from \"../schema\";\n\n/**\n * Content Block Query Operations\n * Handles database queries for content blocks with proper access control\n */\n\n// =============================================================================\n// BASIC CONTENT BLOCK QUERIES\n// =============================================================================\n\n/**\n * Get content block by ID\n */\nexport const getContentBlockById = async (\n  blockId: string\n): Promise<ContentBlock | null> => {\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(eq(contentBlocks.id, blockId))\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get all content blocks for a section\n */\nexport const getContentBlocksBySectionId = async (\n  sectionId: string,\n  options: {\n    blockType?: ContentBlockType;\n    sortBy?: \"orderIndex\" | \"blockType\" | \"createdAt\";\n    sortOrder?: \"asc\" | \"desc\";\n  } = {}\n): Promise<ContentBlock[]> => {\n  const { blockType, sortBy = \"orderIndex\", sortOrder = \"asc\" } = options;\n\n  let whereClause = eq(contentBlocks.sectionId, sectionId);\n\n  if (blockType) {\n    whereClause = and(whereClause, eq(contentBlocks.blockType, blockType));\n  }\n\n  const orderBy =\n    sortOrder === \"desc\"\n      ? desc(contentBlocks[sortBy])\n      : asc(contentBlocks[sortBy]);\n\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(whereClause)\n    .orderBy(orderBy);\n\n  return result;\n};\n\n/**\n * Get content blocks by type across all sections\n */\nexport const getContentBlocksByType = async (\n  blockType: ContentBlockType,\n  options: {\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<ContentBlock[]> => {\n  const { limit = 20, offset = 0 } = options;\n\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(eq(contentBlocks.blockType, blockType))\n    .orderBy(asc(contentBlocks.createdAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// CONTENT BLOCK CREATION AND UPDATES\n// =============================================================================\n\n/**\n * Create a new content block\n */\nexport const createContentBlock = async (\n  blockData: NewContentBlock\n): Promise<ContentBlock> => {\n  const result = await db.insert(contentBlocks).values(blockData).returning();\n\n  return result[0];\n};\n\n/**\n * Update content block\n */\nexport const updateContentBlock = async (\n  blockId: string,\n  updates: Partial<ContentBlock>\n): Promise<ContentBlock | null> => {\n  const result = await db\n    .update(contentBlocks)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(contentBlocks.id, blockId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Delete content block\n */\nexport const deleteContentBlock = async (blockId: string): Promise<boolean> => {\n  const result = await db\n    .delete(contentBlocks)\n    .where(eq(contentBlocks.id, blockId))\n    .returning();\n\n  return result.length > 0;\n};\n\n// =============================================================================\n// CONTENT BLOCK ORDERING OPERATIONS\n// =============================================================================\n\n/**\n * Update content block order\n */\nexport const updateContentBlockOrder = async (\n  blockId: string,\n  newOrderIndex: number\n): Promise<ContentBlock | null> => {\n  const result = await db\n    .update(contentBlocks)\n    .set({\n      orderIndex: newOrderIndex,\n      updatedAt: new Date(),\n    })\n    .where(eq(contentBlocks.id, blockId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Reorder multiple content blocks\n */\nexport const reorderContentBlocks = async (\n  sectionId: string,\n  blockOrders: Array<{ blockId: string; orderIndex: number }>\n): Promise<ContentBlock[]> => {\n  const results: ContentBlock[] = [];\n\n  for (const order of blockOrders) {\n    const result = await updateContentBlockOrder(\n      order.blockId,\n      order.orderIndex\n    );\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  return results;\n};\n\n/**\n * Get next available order index for a section\n */\nexport const getNextContentBlockOrderIndex = async (\n  sectionId: string\n): Promise<number> => {\n  const result = await db\n    .select({ maxOrder: sql<number>`max(${contentBlocks.orderIndex})` })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId));\n\n  return (result[0]?.maxOrder || 0) + 1;\n};\n\n// =============================================================================\n// CONTENT BLOCK VALIDATION QUERIES\n// =============================================================================\n\n/**\n * Check if order index is unique within a section\n */\nexport const isContentBlockOrderIndexUnique = async (\n  sectionId: string,\n  orderIndex: number,\n  excludeBlockId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(contentBlocks.sectionId, sectionId),\n    eq(contentBlocks.orderIndex, orderIndex)\n  );\n\n  if (excludeBlockId) {\n    whereClause = and(\n      whereClause,\n      sql`${contentBlocks.id} != ${excludeBlockId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: contentBlocks.id })\n    .from(contentBlocks)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n/**\n * Validate content block content based on block type\n */\nexport const validateContentBlockContent = async (\n  blockType: ContentBlockType,\n  content: Record<string, unknown>\n): Promise<{ isValid: boolean; errors: string[] }> => {\n  const errors: string[] = [];\n\n  switch (blockType) {\n    case \"hero\":\n      if (!content.title) errors.push(\"Hero blocks require a title\");\n      break;\n\n    case \"text\":\n      if (!content.content && !content.text) {\n        errors.push(\"Text blocks require content or text\");\n      }\n      break;\n\n    case \"image\":\n      if (!content.image?.url) {\n        errors.push(\"Image blocks require an image URL\");\n      }\n      break;\n\n    case \"table\":\n      if (!content.table?.headers || !content.table?.rows) {\n        errors.push(\"Table blocks require headers and rows\");\n      }\n      break;\n\n    case \"list\":\n      if (!content.list?.items || !Array.isArray(content.list.items)) {\n        errors.push(\"List blocks require items array\");\n      }\n      break;\n\n    case \"callout\":\n      if (!content.callout?.type || !content.callout?.content) {\n        errors.push(\"Callout blocks require type and content\");\n      }\n      break;\n\n    case \"quote\":\n      if (!content.quote?.text) {\n        errors.push(\"Quote blocks require text\");\n      }\n      break;\n\n    case \"video\":\n      if (!content.video?.url) {\n        errors.push(\"Video blocks require a video URL\");\n      }\n      break;\n\n    case \"audio\":\n      if (!content.audio?.url) {\n        errors.push(\"Audio blocks require an audio URL\");\n      }\n      break;\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n// =============================================================================\n// CONTENT BLOCK STATISTICS QUERIES\n// =============================================================================\n\n/**\n * Get content block statistics for a section\n */\nexport const getContentBlockStatistics = async (\n  sectionId: string\n): Promise<{\n  totalBlocks: number;\n  blocksByType: Record<ContentBlockType, number>;\n  blocksWithMetadata: number;\n  blocksWithoutMetadata: number;\n} | null> => {\n  // Get total count\n  const totalResult = await db\n    .select({ count: sql<number>`count(*)` })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId));\n\n  // Get count by type\n  const typeResult = await db\n    .select({\n      blockType: contentBlocks.blockType,\n      count: sql<number>`count(*)`,\n    })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId))\n    .groupBy(contentBlocks.blockType);\n\n  // Get blocks with/without metadata\n  const metadataResult = await db\n    .select({\n      withMetadata: sql<number>`count(*) filter (where ${contentBlocks.metadata} is not null)`,\n      withoutMetadata: sql<number>`count(*) filter (where ${contentBlocks.metadata} is null)`,\n    })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId));\n\n  const blocksByType = typeResult.reduce(\n    (acc, row) => {\n      acc[row.blockType] = row.count;\n      return acc;\n    },\n    {} as Record<ContentBlockType, number>\n  );\n\n  return {\n    totalBlocks: totalResult[0]?.count || 0,\n    blocksByType,\n    blocksWithMetadata: metadataResult[0]?.withMetadata || 0,\n    blocksWithoutMetadata: metadataResult[0]?.withoutMetadata || 0,\n  };\n};\n\n// =============================================================================\n// CONTENT BLOCK SEARCH QUERIES\n// =============================================================================\n\n/**\n * Search content blocks by content\n */\nexport const searchContentBlocks = async (\n  sectionId: string,\n  searchTerm: string,\n  options: {\n    blockType?: ContentBlockType;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<ContentBlock[]> => {\n  const { blockType, limit = 20, offset = 0 } = options;\n\n  let whereClause = and(\n    eq(contentBlocks.sectionId, sectionId),\n    sql`${contentBlocks.content}::text ilike ${`%${searchTerm}%`}`\n  );\n\n  if (blockType) {\n    whereClause = and(whereClause, eq(contentBlocks.blockType, blockType));\n  }\n\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(whereClause)\n    .orderBy(asc(contentBlocks.orderIndex))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n/**\n * Search content blocks across all sections\n */\nexport const searchAllContentBlocks = async (\n  searchTerm: string,\n  options: {\n    blockType?: ContentBlockType;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<ContentBlock[]> => {\n  const { blockType, limit = 20, offset = 0 } = options;\n\n  let whereClause = sql`${contentBlocks.content}::text ilike ${`%${searchTerm}%`}`;\n\n  if (blockType) {\n    whereClause = and(whereClause, eq(contentBlocks.blockType, blockType));\n  }\n\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(whereClause)\n    .orderBy(asc(contentBlocks.createdAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// CONTENT BLOCK ACCESS CONTROL QUERIES\n// =============================================================================\n\n/**\n * Get content blocks accessible to user based on role and section access\n */\nexport const getAccessibleContentBlocks = async (\n  sectionId: string,\n  userRole: string,\n  options: {\n    blockType?: ContentBlockType;\n  } = {}\n): Promise<ContentBlock[]> => {\n  // All roles can access content blocks if they have section access\n  // Access control is handled at the section level\n  return getContentBlocksBySectionId(sectionId, options);\n};\n\n/**\n * Check if user can access a specific content block\n */\nexport const canUserAccessContentBlock = async (\n  blockId: string,\n  userRole: string\n): Promise<boolean> => {\n  const block = await getContentBlockById(blockId);\n  if (!block) return false;\n\n  // Access control is handled at the section level\n  // If user can access the section, they can access the content blocks\n  return true;\n};\n\n// =============================================================================\n// CONTENT BLOCK BULK OPERATIONS\n// =============================================================================\n\n/**\n * Bulk create content blocks\n */\nexport const bulkCreateContentBlocks = async (\n  blocksData: NewContentBlock[]\n): Promise<ContentBlock[]> => {\n  const result = await db.insert(contentBlocks).values(blocksData).returning();\n\n  return result;\n};\n\n/**\n * Bulk update content blocks\n */\nexport const bulkUpdateContentBlocks = async (\n  updates: Array<{ id: string; updates: Partial<ContentBlock> }>\n): Promise<ContentBlock[]> => {\n  const results: ContentBlock[] = [];\n\n  for (const update of updates) {\n    const result = await updateContentBlock(update.id, update.updates);\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  return results;\n};\n\n/**\n * Bulk delete content blocks\n */\nexport const bulkDeleteContentBlocks = async (\n  blockIds: string[]\n): Promise<number> => {\n  const result = await db\n    .delete(contentBlocks)\n    .where(sql`${contentBlocks.id} = any(${blockIds})`)\n    .returning();\n\n  return result.length;\n};\n","import { eq, and, desc, asc, sql } from \"drizzle-orm\";\nimport { db } from \"../index\";\nimport {\n  quizQuestions,\n  quizAttempts,\n  courseSections,\n  QuizQuestion,\n  NewQuizQuestion,\n  questionTypeEnum,\n} from \"../schema\";\n\n/**\n * Quiz Question Query Operations\n * Handles database queries for quiz questions with proper access control\n */\n\n// =============================================================================\n// BASIC QUIZ QUESTION QUERIES\n// =============================================================================\n\n/**\n * Get quiz question by ID\n */\nexport const getQuizQuestionById = async (\n  questionId: string\n): Promise<QuizQuestion | null> => {\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(eq(quizQuestions.id, questionId))\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get quiz question by section ID and question key\n */\nexport const getQuizQuestionByKey = async (\n  sectionId: string,\n  questionKey: string\n): Promise<QuizQuestion | null> => {\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(\n      and(\n        eq(quizQuestions.sectionId, sectionId),\n        eq(quizQuestions.questionKey, questionKey)\n      )\n    )\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get all quiz questions for a section\n */\nexport const getQuizQuestionsBySectionId = async (\n  sectionId: string,\n  options: {\n    questionType?: typeof questionTypeEnum.enumValues[number];\n    includeUnpublished?: boolean;\n    sortBy?: \"orderIndex\" | \"questionKey\" | \"createdAt\";\n    sortOrder?: \"asc\" | \"desc\";\n  } = {}\n): Promise<QuizQuestion[]> => {\n  const {\n    questionType,\n    includeUnpublished = false,\n    sortBy = \"orderIndex\",\n    sortOrder = \"asc\",\n  } = options;\n\n  let whereClause = eq(quizQuestions.sectionId, sectionId);\n\n  if (questionType) {\n    whereClause = and(\n      whereClause,\n      eq(quizQuestions.questionType, questionType)\n    );\n  }\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(quizQuestions.isPublished, true));\n  }\n\n  const orderBy =\n    sortOrder === \"desc\"\n      ? desc(quizQuestions[sortBy])\n      : asc(quizQuestions[sortBy]);\n\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(whereClause)\n    .orderBy(orderBy);\n\n  return result;\n};\n\n/**\n * Get quiz questions by type across all sections\n */\nexport const getQuizQuestionsByType = async (\n  questionType: typeof questionTypeEnum.enumValues[number],\n  options: {\n    includeUnpublished?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<QuizQuestion[]> => {\n  const { includeUnpublished = false, limit = 20, offset = 0 } = options;\n\n  let whereClause = eq(quizQuestions.questionType, questionType);\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(quizQuestions.isPublished, true));\n  }\n\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(whereClause)\n    .orderBy(asc(quizQuestions.createdAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// QUIZ QUESTION CREATION AND UPDATES\n// =============================================================================\n\n/**\n * Create a new quiz question\n */\nexport const createQuizQuestion = async (\n  questionData: NewQuizQuestion\n): Promise<QuizQuestion> => {\n  const result = await db\n    .insert(quizQuestions)\n    .values(questionData)\n    .returning();\n\n  return result[0];\n};\n\n/**\n * Update quiz question\n */\nexport const updateQuizQuestion = async (\n  questionId: string,\n  updates: Partial<QuizQuestion>\n): Promise<QuizQuestion | null> => {\n  const result = await db\n    .update(quizQuestions)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(quizQuestions.id, questionId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Delete quiz question\n */\nexport const deleteQuizQuestion = async (\n  questionId: string\n): Promise<boolean> => {\n  const result = await db\n    .delete(quizQuestions)\n    .where(eq(quizQuestions.id, questionId))\n    .returning();\n\n  return result.length > 0;\n};\n\n// =============================================================================\n// QUIZ QUESTION ORDERING OPERATIONS\n// =============================================================================\n\n/**\n * Update quiz question order\n */\nexport const updateQuizQuestionOrder = async (\n  questionId: string,\n  newOrderIndex: number\n): Promise<QuizQuestion | null> => {\n  const result = await db\n    .update(quizQuestions)\n    .set({\n      orderIndex: newOrderIndex,\n      updatedAt: new Date(),\n    })\n    .where(eq(quizQuestions.id, questionId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Reorder multiple quiz questions\n */\nexport const reorderQuizQuestions = async (\n  sectionId: string,\n  questionOrders: Array<{ questionId: string; orderIndex: number }>\n): Promise<QuizQuestion[]> => {\n  const results: QuizQuestion[] = [];\n\n  for (const order of questionOrders) {\n    const result = await updateQuizQuestionOrder(\n      order.questionId,\n      order.orderIndex\n    );\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  return results;\n};\n\n/**\n * Get next available order index for a section\n */\nexport const getNextQuizQuestionOrderIndex = async (\n  sectionId: string\n): Promise<number> => {\n  const result = await db\n    .select({ maxOrder: sql<number>`max(${quizQuestions.orderIndex})` })\n    .from(quizQuestions)\n    .where(eq(quizQuestions.sectionId, sectionId));\n\n  return (result[0]?.maxOrder || 0) + 1;\n};\n\n// =============================================================================\n// QUIZ QUESTION VALIDATION QUERIES\n// =============================================================================\n\n/**\n * Check if question key is unique within a section\n */\nexport const isQuestionKeyUnique = async (\n  sectionId: string,\n  questionKey: string,\n  excludeQuestionId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(quizQuestions.sectionId, sectionId),\n    eq(quizQuestions.questionKey, questionKey)\n  );\n\n  if (excludeQuestionId) {\n    whereClause = and(\n      whereClause,\n      sql`${quizQuestions.id} != ${excludeQuestionId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: quizQuestions.id })\n    .from(quizQuestions)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n/**\n * Check if order index is unique within a section\n */\nexport const isQuizQuestionOrderIndexUnique = async (\n  sectionId: string,\n  orderIndex: number,\n  excludeQuestionId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(quizQuestions.sectionId, sectionId),\n    eq(quizQuestions.orderIndex, orderIndex)\n  );\n\n  if (excludeQuestionId) {\n    whereClause = and(\n      whereClause,\n      sql`${quizQuestions.id} != ${excludeQuestionId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: quizQuestions.id })\n    .from(quizQuestions)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n/**\n * Validate quiz question content based on question type\n */\nexport const validateQuizQuestionContent = async (\n  questionType: typeof questionTypeEnum.enumValues[number],\n  questionText: string,\n  options?: Record<string, string>,\n  correctAnswer?: unknown\n): Promise<{ isValid: boolean; errors: string[] }> => {\n  const errors: string[] = [];\n\n  if (!questionText || questionText.trim().length === 0) {\n    errors.push(\"Question text is required\");\n  }\n\n  switch (questionType) {\n    case \"true-false\":\n      if (typeof correctAnswer !== \"boolean\") {\n        errors.push(\"True/false questions require a boolean correct answer\");\n      }\n      break;\n\n    case \"multiple-choice\":\n      if (!options || Object.keys(options).length === 0) {\n        errors.push(\"Multiple choice questions require options\");\n      }\n      if (\n        typeof correctAnswer !== \"string\" ||\n        !options ||\n        !(correctAnswer in options)\n      ) {\n        errors.push(\"Correct answer must be one of the provided options\");\n      }\n      break;\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n// =============================================================================\n// QUIZ ATTEMPT QUERIES\n// =============================================================================\n\n/**\n * Create quiz attempt\n */\nexport const createQuizAttempt = async (attemptData: {\n  userId: string;\n  quizQuestionId: string;\n  userAnswer: unknown;\n  isCorrect: boolean;\n  timeSpentSeconds: number;\n}): Promise<any> => {\n  const result = await db\n    .insert(quizAttempts)\n    .values({\n      ...attemptData,\n      attemptedAt: new Date(),\n    })\n    .returning();\n\n  return result[0];\n};\n\n/**\n * Get quiz attempts for a user\n */\nexport const getQuizAttemptsByUser = async (\n  userId: string,\n  options: {\n    quizQuestionId?: string;\n    isCorrect?: boolean;\n    dateFrom?: Date;\n    dateTo?: Date;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<any[]> => {\n  const {\n    quizQuestionId,\n    isCorrect,\n    dateFrom,\n    dateTo,\n    limit = 20,\n    offset = 0,\n  } = options;\n\n  let whereClause = eq(quizAttempts.userId, userId);\n\n  if (quizQuestionId) {\n    whereClause = and(\n      whereClause,\n      eq(quizAttempts.quizQuestionId, quizQuestionId)\n    );\n  }\n\n  if (isCorrect !== undefined) {\n    whereClause = and(whereClause, eq(quizAttempts.isCorrect, isCorrect));\n  }\n\n  if (dateFrom) {\n    whereClause = and(\n      whereClause,\n      sql`${quizAttempts.attemptedAt} >= ${dateFrom}`\n    );\n  }\n\n  if (dateTo) {\n    whereClause = and(\n      whereClause,\n      sql`${quizAttempts.attemptedAt} <= ${dateTo}`\n    );\n  }\n\n  const result = await db\n    .select()\n    .from(quizAttempts)\n    .where(whereClause)\n    .orderBy(desc(quizAttempts.attemptedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n/**\n * Get quiz attempts for a question\n */\nexport const getQuizAttemptsByQuestion = async (\n  quizQuestionId: string,\n  options: {\n    userId?: string;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<any[]> => {\n  const { userId, limit = 20, offset = 0 } = options;\n\n  let whereClause = eq(quizAttempts.quizQuestionId, quizQuestionId);\n\n  if (userId) {\n    whereClause = and(whereClause, eq(quizAttempts.userId, userId));\n  }\n\n  const result = await db\n    .select()\n    .from(quizAttempts)\n    .where(whereClause)\n    .orderBy(desc(quizAttempts.attemptedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// QUIZ QUESTION STATISTICS QUERIES\n// =============================================================================\n\n/**\n * Get quiz question statistics\n */\nexport const getQuizQuestionStatistics = async (\n  questionId: string\n): Promise<{\n  totalAttempts: number;\n  correctAttempts: number;\n  incorrectAttempts: number;\n  averageTimeSpent: number;\n  successRate: number;\n  lastAttempted?: Date;\n} | null> => {\n  const question = await getQuizQuestionById(questionId);\n  if (!question) return null;\n\n  const attempts = await getQuizAttemptsByQuestion(questionId);\n\n  const totalAttempts = attempts.length;\n  const correctAttempts = attempts.filter(a => a.isCorrect).length;\n  const incorrectAttempts = totalAttempts - correctAttempts;\n  const averageTimeSpent =\n    totalAttempts > 0\n      ? attempts.reduce((sum, a) => sum + a.timeSpentSeconds, 0) / totalAttempts\n      : 0;\n  const successRate =\n    totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0;\n  const lastAttempted =\n    attempts.length > 0\n      ? attempts.sort(\n          (a, b) => b.attemptedAt.getTime() - a.attemptedAt.getTime()\n        )[0].attemptedAt\n      : undefined;\n\n  return {\n    totalAttempts,\n    correctAttempts,\n    incorrectAttempts,\n    averageTimeSpent,\n    successRate,\n    lastAttempted,\n  };\n};\n\n/**\n * Get section quiz statistics\n */\nexport const getSectionQuizStatistics = async (\n  sectionId: string\n): Promise<{\n  totalQuestions: number;\n  publishedQuestions: number;\n  totalAttempts: number;\n  averageSuccessRate: number;\n  questionsByType: Record<typeof questionTypeEnum.enumValues[number], number>;\n} | null> => {\n  // Get questions in section\n  const questions = await getQuizQuestionsBySectionId(sectionId, {\n    includeUnpublished: true,\n  });\n\n  if (questions.length === 0) {\n    return {\n      totalQuestions: 0,\n      publishedQuestions: 0,\n      totalAttempts: 0,\n      averageSuccessRate: 0,\n      questionsByType: { \"true-false\": 0, \"multiple-choice\": 0 },\n    };\n  }\n\n  const publishedQuestions = questions.filter(q => q.isPublished).length;\n\n  // Get attempts for all questions\n  const questionIds = questions.map(q => q.id);\n  const attempts = await db\n    .select()\n    .from(quizAttempts)\n    .where(sql`${quizAttempts.quizQuestionId} = any(${questionIds})`);\n\n  const totalAttempts = attempts.length;\n  const correctAttempts = attempts.filter(a => a.isCorrect).length;\n  const averageSuccessRate =\n    totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0;\n\n  const questionsByType = questions.reduce(\n    (acc, q) => {\n      acc[q.questionType] = (acc[q.questionType] || 0) + 1;\n      return acc;\n    },\n    {} as Record<typeof questionTypeEnum.enumValues[number], number>\n  );\n\n  return {\n    totalQuestions: questions.length,\n    publishedQuestions,\n    totalAttempts,\n    averageSuccessRate,\n    questionsByType,\n  };\n};\n\n// =============================================================================\n// QUIZ QUESTION SEARCH QUERIES\n// =============================================================================\n\n/**\n * Search quiz questions by text\n */\nexport const searchQuizQuestions = async (\n  sectionId: string,\n  searchTerm: string,\n  options: {\n    questionType?: typeof questionTypeEnum.enumValues[number];\n    includeUnpublished?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<QuizQuestion[]> => {\n  const {\n    questionType,\n    includeUnpublished = false,\n    limit = 20,\n    offset = 0,\n  } = options;\n\n  let whereClause = and(\n    eq(quizQuestions.sectionId, sectionId),\n    sql`${quizQuestions.questionText} ilike ${`%${searchTerm}%`}`\n  );\n\n  if (questionType) {\n    whereClause = and(\n      whereClause,\n      eq(quizQuestions.questionType, questionType)\n    );\n  }\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(quizQuestions.isPublished, true));\n  }\n\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(whereClause)\n    .orderBy(asc(quizQuestions.orderIndex))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n/**\n * Search quiz questions across all sections\n */\nexport const searchAllQuizQuestions = async (\n  searchTerm: string,\n  options: {\n    questionType?: typeof questionTypeEnum.enumValues[number];\n    includeUnpublished?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<QuizQuestion[]> => {\n  const {\n    questionType,\n    includeUnpublished = false,\n    limit = 20,\n    offset = 0,\n  } = options;\n\n  let whereClause = sql`${quizQuestions.questionText} ilike ${`%${searchTerm}%`}`;\n\n  if (questionType) {\n    whereClause = and(\n      whereClause,\n      eq(quizQuestions.questionType, questionType)\n    );\n  }\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(quizQuestions.isPublished, true));\n  }\n\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(whereClause)\n    .orderBy(asc(quizQuestions.createdAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// QUIZ QUESTION ACCESS CONTROL QUERIES\n// =============================================================================\n\n/**\n * Get quiz questions accessible to user based on role and section access\n */\nexport const getAccessibleQuizQuestions = async (\n  sectionId: string,\n  userRole: string,\n  options: {\n    questionType?: typeof questionTypeEnum.enumValues[number];\n  } = {}\n): Promise<QuizQuestion[]> => {\n  // All roles can access published quiz questions if they have section access\n  // Access control is handled at the section level\n  return getQuizQuestionsBySectionId(sectionId, {\n    ...options,\n    includeUnpublished: userRole === \"safety_admin\",\n  });\n};\n\n/**\n * Check if user can access a specific quiz question\n */\nexport const canUserAccessQuizQuestion = async (\n  questionId: string,\n  userRole: string\n): Promise<boolean> => {\n  const question = await getQuizQuestionById(questionId);\n  if (!question) return false;\n\n  // Safety admins can access all questions\n  if (userRole === \"safety_admin\") return true;\n\n  // Other roles can only access published questions\n  return question.isPublished;\n};\n","import { eq, and, desc, asc, sql, gte, lte } from \"drizzle-orm\";\nimport { db } from \"../index\";\nimport {\n  userProgress,\n  courses,\n  courseSections,\n  UserProgress,\n  NewUserProgress,\n} from \"../schema\";\n\n/**\n * User Progress Query Operations\n * Handles database queries for user progress tracking with proper access control\n */\n\n// =============================================================================\n// BASIC USER PROGRESS QUERIES\n// =============================================================================\n\n/**\n * Get user progress by ID\n */\nexport const getUserProgressById = async (\n  progressId: string\n): Promise<UserProgress | null> => {\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(eq(userProgress.id, progressId))\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get user progress by user ID and section ID\n */\nexport const getUserProgressByUserAndSection = async (\n  userId: string,\n  sectionId: string\n): Promise<UserProgress | null> => {\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(\n      and(\n        eq(userProgress.userId, userId),\n        eq(userProgress.sectionId, sectionId)\n      )\n    )\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get all progress records for a user\n */\nexport const getUserProgressByUser = async (\n  userId: string,\n  options: {\n    courseId?: string;\n    sectionId?: string;\n    isCompleted?: boolean;\n    completionPercentageMin?: number;\n    completionPercentageMax?: number;\n    dateFrom?: Date;\n    dateTo?: Date;\n    sortBy?: \"lastAccessedAt\" | \"completedAt\" | \"createdAt\";\n    sortOrder?: \"asc\" | \"desc\";\n  } = {}\n): Promise<UserProgress[]> => {\n  const {\n    courseId,\n    sectionId,\n    isCompleted,\n    completionPercentageMin,\n    completionPercentageMax,\n    dateFrom,\n    dateTo,\n    sortBy = \"lastAccessedAt\",\n    sortOrder = \"desc\",\n  } = options;\n\n  let whereClause = eq(userProgress.userId, userId);\n\n  if (courseId) {\n    whereClause = and(whereClause, eq(userProgress.courseId, courseId));\n  }\n\n  if (sectionId) {\n    whereClause = and(whereClause, eq(userProgress.sectionId, sectionId));\n  }\n\n  if (isCompleted !== undefined) {\n    whereClause = and(whereClause, eq(userProgress.isCompleted, isCompleted));\n  }\n\n  if (completionPercentageMin !== undefined) {\n    whereClause = and(\n      whereClause,\n      gte(userProgress.completionPercentage, completionPercentageMin)\n    );\n  }\n\n  if (completionPercentageMax !== undefined) {\n    whereClause = and(\n      whereClause,\n      lte(userProgress.completionPercentage, completionPercentageMax)\n    );\n  }\n\n  if (dateFrom) {\n    whereClause = and(whereClause, gte(userProgress.lastAccessedAt, dateFrom));\n  }\n\n  if (dateTo) {\n    whereClause = and(whereClause, lte(userProgress.lastAccessedAt, dateTo));\n  }\n\n  const orderBy =\n    sortOrder === \"desc\"\n      ? desc(userProgress[sortBy])\n      : asc(userProgress[sortBy]);\n\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(whereClause)\n    .orderBy(orderBy);\n\n  return result;\n};\n\n/**\n * Get all progress records for a course\n */\nexport const getUserProgressByCourse = async (\n  courseId: string,\n  options: {\n    userId?: string;\n    isCompleted?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<UserProgress[]> => {\n  const { userId, isCompleted, limit = 20, offset = 0 } = options;\n\n  let whereClause = eq(userProgress.courseId, courseId);\n\n  if (userId) {\n    whereClause = and(whereClause, eq(userProgress.userId, userId));\n  }\n\n  if (isCompleted !== undefined) {\n    whereClause = and(whereClause, eq(userProgress.isCompleted, isCompleted));\n  }\n\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(whereClause)\n    .orderBy(desc(userProgress.lastAccessedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n/**\n * Get all progress records for a section\n */\nexport const getUserProgressBySection = async (\n  sectionId: string,\n  options: {\n    userId?: string;\n    isCompleted?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<UserProgress[]> => {\n  const { userId, isCompleted, limit = 20, offset = 0 } = options;\n\n  let whereClause = eq(userProgress.sectionId, sectionId);\n\n  if (userId) {\n    whereClause = and(whereClause, eq(userProgress.userId, userId));\n  }\n\n  if (isCompleted !== undefined) {\n    whereClause = and(whereClause, eq(userProgress.isCompleted, isCompleted));\n  }\n\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(whereClause)\n    .orderBy(desc(userProgress.lastAccessedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// USER PROGRESS CREATION AND UPDATES\n// =============================================================================\n\n/**\n * Create or update user progress\n */\nexport const upsertUserProgress = async (\n  progressData: NewUserProgress\n): Promise<UserProgress> => {\n  const result = await db\n    .insert(userProgress)\n    .values(progressData)\n    .onConflictDoUpdate({\n      target: [userProgress.userId, userProgress.sectionId],\n      set: {\n        isCompleted: progressData.isCompleted,\n        completionPercentage: progressData.completionPercentage,\n        timeSpentSeconds: progressData.timeSpentSeconds,\n        lastAccessedAt: progressData.lastAccessedAt,\n        completedAt: progressData.completedAt,\n        updatedAt: new Date(),\n      },\n    })\n    .returning();\n\n  return result[0];\n};\n\n/**\n * Update user progress\n */\nexport const updateUserProgress = async (\n  progressId: string,\n  updates: Partial<UserProgress>\n): Promise<UserProgress | null> => {\n  const result = await db\n    .update(userProgress)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(userProgress.id, progressId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Update user progress by user and section\n */\nexport const updateUserProgressByUserAndSection = async (\n  userId: string,\n  sectionId: string,\n  updates: Partial<UserProgress>\n): Promise<UserProgress | null> => {\n  const result = await db\n    .update(userProgress)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(\n      and(\n        eq(userProgress.userId, userId),\n        eq(userProgress.sectionId, sectionId)\n      )\n    )\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Delete user progress\n */\nexport const deleteUserProgress = async (\n  progressId: string\n): Promise<boolean> => {\n  const result = await db\n    .delete(userProgress)\n    .where(eq(userProgress.id, progressId))\n    .returning();\n\n  return result.length > 0;\n};\n\n// =============================================================================\n// COURSE COMPLETION STATUS QUERIES\n// =============================================================================\n\n/**\n * Calculate course completion status for a user\n */\nexport const calculateCourseCompletionStatus = async (\n  userId: string,\n  courseId: string\n): Promise<{\n  courseId: string;\n  userId: string;\n  totalSections: number;\n  completedSections: number;\n  completionPercentage: number;\n  timeSpentSeconds: number;\n  lastAccessedAt: Date;\n  completedAt?: Date;\n} | null> => {\n  // Get all sections for the course\n  const sections = await db\n    .select()\n    .from(courseSections)\n    .where(eq(courseSections.courseId, courseId));\n\n  if (sections.length === 0) return null;\n\n  // Get user progress for this course\n  const progressRecords = await getUserProgressByUser(userId, { courseId });\n\n  const completedSections = progressRecords.filter(p => p.isCompleted).length;\n  const completionPercentage = Math.round(\n    (completedSections / sections.length) * 100\n  );\n  const timeSpentSeconds = progressRecords.reduce(\n    (sum, p) => sum + p.timeSpentSeconds,\n    0\n  );\n\n  const lastAccessedAt =\n    progressRecords.length > 0\n      ? progressRecords.reduce(\n          (latest, p) =>\n            p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n          progressRecords[0].lastAccessedAt\n        )\n      : new Date();\n\n  const completedAt =\n    completedSections === sections.length && sections.length > 0\n      ? progressRecords.reduce(\n          (latest, p) =>\n            p.completedAt && p.completedAt > latest ? p.completedAt : latest,\n          progressRecords[0].completedAt || new Date(0)\n        )\n      : undefined;\n\n  return {\n    courseId,\n    userId,\n    totalSections: sections.length,\n    completedSections,\n    completionPercentage,\n    timeSpentSeconds,\n    lastAccessedAt,\n    completedAt:\n      completedAt && completedAt.getTime() > 0 ? completedAt : undefined,\n  };\n};\n\n/**\n * Get course completion status for multiple users\n */\nexport const getCourseCompletionStatusForUsers = async (\n  courseId: string,\n  userIds: string[]\n): Promise<\n  Array<{\n    userId: string;\n    courseId: string;\n    totalSections: number;\n    completedSections: number;\n    completionPercentage: number;\n    timeSpentSeconds: number;\n    lastAccessedAt: Date;\n    completedAt?: Date;\n  }>\n> => {\n  const results = [];\n\n  for (const userId of userIds) {\n    const status = await calculateCourseCompletionStatus(userId, courseId);\n    if (status) {\n      results.push(status);\n    }\n  }\n\n  return results;\n};\n\n// =============================================================================\n// USER PROGRESS ANALYTICS QUERIES\n// =============================================================================\n\n/**\n * Get user progress analytics\n */\nexport const getUserProgressAnalytics = async (\n  userId: string\n): Promise<{\n  userId: string;\n  totalCourses: number;\n  completedCourses: number;\n  inProgressCourses: number;\n  totalTimeSpent: number;\n  averageCompletionRate: number;\n  lastActivity?: Date;\n  coursesByStatus: {\n    completed: string[];\n    inProgress: string[];\n    notStarted: string[];\n  };\n} | null> => {\n  // Get all courses\n  const allCourses = await db\n    .select()\n    .from(courses)\n    .where(eq(courses.isPublished, true));\n\n  if (allCourses.length === 0) {\n    return {\n      userId,\n      totalCourses: 0,\n      completedCourses: 0,\n      inProgressCourses: 0,\n      totalTimeSpent: 0,\n      averageCompletionRate: 0,\n      coursesByStatus: {\n        completed: [],\n        inProgress: [],\n        notStarted: [],\n      },\n    };\n  }\n\n  // Get user progress for all courses\n  const userProgressRecords = await getUserProgressByUser(userId);\n\n  const totalCourses = allCourses.length;\n  let completedCourses = 0;\n  let inProgressCourses = 0;\n  const totalTimeSpent = userProgressRecords.reduce(\n    (sum, p) => sum + p.timeSpentSeconds,\n    0\n  );\n\n  const coursesByStatus = {\n    completed: [] as string[],\n    inProgress: [] as string[],\n    notStarted: [] as string[],\n  };\n\n  // Analyze each course\n  for (const course of allCourses) {\n    const courseProgress = userProgressRecords.filter(\n      p => p.courseId === course.id\n    );\n    const completedSections = courseProgress.filter(p => p.isCompleted).length;\n    const totalSections = courseProgress.length;\n\n    if (totalSections === 0) {\n      coursesByStatus.notStarted.push(course.id);\n    } else if (completedSections === totalSections && totalSections > 0) {\n      completedCourses++;\n      coursesByStatus.completed.push(course.id);\n    } else {\n      inProgressCourses++;\n      coursesByStatus.inProgress.push(course.id);\n    }\n  }\n\n  const averageCompletionRate =\n    totalCourses > 0 ? (completedCourses / totalCourses) * 100 : 0;\n\n  const lastActivity =\n    userProgressRecords.length > 0\n      ? userProgressRecords.reduce(\n          (latest, p) =>\n            p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n          userProgressRecords[0].lastAccessedAt\n        )\n      : undefined;\n\n  return {\n    userId,\n    totalCourses,\n    completedCourses,\n    inProgressCourses,\n    totalTimeSpent,\n    averageCompletionRate,\n    lastActivity,\n    coursesByStatus,\n  };\n};\n\n// =============================================================================\n// USER PROGRESS STATISTICS QUERIES\n// =============================================================================\n\n/**\n * Get course progress statistics\n */\nexport const getCourseProgressStatistics = async (\n  courseId: string\n): Promise<{\n  totalUsers: number;\n  completedUsers: number;\n  inProgressUsers: number;\n  averageCompletionRate: number;\n  averageTimeSpent: number;\n  lastActivity?: Date;\n} | null> => {\n  const course = await db\n    .select()\n    .from(courses)\n    .where(eq(courses.id, courseId))\n    .limit(1);\n\n  if (!course[0]) return null;\n\n  // Get all progress records for this course\n  const progressRecords = await getUserProgressByCourse(courseId);\n\n  if (progressRecords.length === 0) {\n    return {\n      totalUsers: 0,\n      completedUsers: 0,\n      inProgressUsers: 0,\n      averageCompletionRate: 0,\n      averageTimeSpent: 0,\n    };\n  }\n\n  // Group by user\n  const userProgressMap = new Map<string, UserProgress[]>();\n  progressRecords.forEach(p => {\n    const existing = userProgressMap.get(p.userId) || [];\n    existing.push(p);\n    userProgressMap.set(p.userId, existing);\n  });\n\n  const totalUsers = userProgressMap.size;\n  let completedUsers = 0;\n  let inProgressUsers = 0;\n  let totalTimeSpent = 0;\n\n  // Get total sections for the course\n  const sections = await db\n    .select()\n    .from(courseSections)\n    .where(eq(courseSections.courseId, courseId));\n\n  const totalSections = sections.length;\n\n  // Analyze each user's progress\n  for (const [userId, userProgress] of userProgressMap) {\n    const completedSections = userProgress.filter(p => p.isCompleted).length;\n    const userTimeSpent = userProgress.reduce(\n      (sum, p) => sum + p.timeSpentSeconds,\n      0\n    );\n    totalTimeSpent += userTimeSpent;\n\n    if (completedSections === totalSections && totalSections > 0) {\n      completedUsers++;\n    } else if (completedSections > 0) {\n      inProgressUsers++;\n    }\n  }\n\n  const averageCompletionRate =\n    totalUsers > 0 ? (completedUsers / totalUsers) * 100 : 0;\n  const averageTimeSpent = totalUsers > 0 ? totalTimeSpent / totalUsers : 0;\n\n  const lastActivity =\n    progressRecords.length > 0\n      ? progressRecords.reduce(\n          (latest, p) =>\n            p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n          progressRecords[0].lastAccessedAt\n        )\n      : undefined;\n\n  return {\n    totalUsers,\n    completedUsers,\n    inProgressUsers,\n    averageCompletionRate,\n    averageTimeSpent,\n    lastActivity,\n  };\n};\n\n// =============================================================================\n// USER PROGRESS SEARCH QUERIES\n// =============================================================================\n\n/**\n * Search user progress records\n */\nexport const searchUserProgress = async (\n  searchTerm: string,\n  options: {\n    userId?: string;\n    courseId?: string;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<UserProgress[]> => {\n  const { userId, courseId, limit = 20, offset = 0 } = options;\n\n  let whereClause = sql`${userProgress.userId} ilike ${`%${searchTerm}%`}`;\n\n  if (userId) {\n    whereClause = and(whereClause, eq(userProgress.userId, userId));\n  }\n\n  if (courseId) {\n    whereClause = and(whereClause, eq(userProgress.courseId, courseId));\n  }\n\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(whereClause)\n    .orderBy(desc(userProgress.lastAccessedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// USER PROGRESS ACCESS CONTROL QUERIES\n// =============================================================================\n\n/**\n * Get user progress accessible to user based on role and ownership\n */\nexport const getAccessibleUserProgress = async (\n  userId: string,\n  userRole: string,\n  options: {\n    courseId?: string;\n    sectionId?: string;\n  } = {}\n): Promise<UserProgress[]> => {\n  // Users can always access their own progress\n  if (userRole === \"employee\" || userRole === \"hr_admin\") {\n    return getUserProgressByUser(userId, options);\n  }\n\n  // Safety admins can access all progress\n  if (userRole === \"safety_admin\") {\n    return getUserProgressByUser(userId, options);\n  }\n\n  // Plant managers can access progress in their plant\n  if (userRole === \"plant_manager\") {\n    return getUserProgressByUser(userId, options);\n  }\n\n  // Default: users can only access their own progress\n  return getUserProgressByUser(userId, options);\n};\n\n/**\n * Check if user can access a specific progress record\n */\nexport const canUserAccessProgress = async (\n  progressId: string,\n  userId: string,\n  userRole: string\n): Promise<boolean> => {\n  const progress = await getUserProgressById(progressId);\n  if (!progress) return false;\n\n  // Users can always access their own progress\n  if (progress.userId === userId) return true;\n\n  // Safety admins can access all progress\n  if (userRole === \"safety_admin\") return true;\n\n  // Plant managers can access progress in their plant\n  if (userRole === \"plant_manager\") return true;\n\n  // HR admins can view progress in their plant\n  if (userRole === \"hr_admin\") return true;\n\n  return false;\n};\n","import { CourseSection, NewCourseSection } from \"../db/schema/course-sections\";\nimport { ContentBlock } from \"../db/schema/content-blocks\";\nimport { QuizQuestion } from \"../db/schema/quiz-questions\";\nimport {\n  CourseSection as CourseSectionSchema,\n  CreateCourseSectionRequest,\n  UpdateCourseSectionRequest,\n  SectionWithContentResponse,\n} from \"@specchem/contracts\";\n\n/**\n * Course Section Data Mappers\n * Handles transformation between course section database entities and API responses\n */\n\n// =============================================================================\n// COURSE SECTION DATABASE  API RESPONSE MAPPERS\n// =============================================================================\n\n/**\n * Maps course section database entity to API response\n */\nexport const mapCourseSectionToApiResponse = (\n  section: CourseSection\n): CourseSectionSchema => ({\n  id: section.id,\n  courseId: section.courseId,\n  sectionKey: section.sectionKey,\n  title: section.title,\n  orderIndex: section.orderIndex,\n  iconName: section.iconName,\n  isPublished: section.isPublished,\n  createdAt: section.createdAt.toISOString(),\n  updatedAt: section.updatedAt.toISOString(),\n});\n\n/**\n * Maps multiple course sections to API responses\n */\nexport const mapCourseSectionsToApiResponses = (\n  sections: CourseSection[]\n): CourseSectionSchema[] => sections.map(mapCourseSectionToApiResponse);\n\n// =============================================================================\n// API REQUEST  COURSE SECTION DATABASE MAPPERS\n// =============================================================================\n\n/**\n * Maps create course section API request to database entity\n */\nexport const mapCreateCourseSectionRequestToDb = (\n  request: CreateCourseSectionRequest,\n  courseId: string\n): NewCourseSection => ({\n  courseId,\n  sectionKey: request.sectionKey,\n  title: request.title,\n  orderIndex: request.orderIndex,\n  iconName: request.iconName,\n  isPublished: request.isPublished,\n});\n\n/**\n * Maps update course section API request to database entity\n */\nexport const mapUpdateCourseSectionRequestToDb = (\n  request: UpdateCourseSectionRequest,\n  existingSection: CourseSection\n): Partial<CourseSection> => ({\n  ...existingSection,\n  sectionKey: request.sectionKey ?? existingSection.sectionKey,\n  title: request.title ?? existingSection.title,\n  orderIndex: request.orderIndex ?? existingSection.orderIndex,\n  iconName: request.iconName ?? existingSection.iconName,\n  isPublished: request.isPublished ?? existingSection.isPublished,\n  updatedAt: new Date(),\n});\n\n// =============================================================================\n// SECTION WITH CONTENT MAPPERS\n// =============================================================================\n\n/**\n * Maps section with content blocks and quiz questions to API response\n */\nexport const mapSectionWithContentToApiResponse = (\n  section: CourseSection,\n  contentBlocks: ContentBlock[],\n  quizQuestions: QuizQuestion[]\n): SectionWithContentResponse[\"data\"] => ({\n  section: mapCourseSectionToApiResponse(section),\n  contentBlocks: contentBlocks.map(mapContentBlockToApiResponse),\n  quizQuestions: quizQuestions.map(mapQuizQuestionToApiResponse),\n});\n\n// =============================================================================\n// HELPER MAPPERS FOR CONTENT BLOCKS AND QUIZ QUESTIONS\n// =============================================================================\n\n/**\n * Maps content block to API response (simplified for this context)\n */\nconst mapContentBlockToApiResponse = (block: ContentBlock) => ({\n  id: block.id,\n  sectionId: block.sectionId,\n  blockType: block.blockType,\n  orderIndex: block.orderIndex,\n  content: block.content,\n  metadata: block.metadata,\n  createdAt: block.createdAt.toISOString(),\n  updatedAt: block.updatedAt.toISOString(),\n});\n\n/**\n * Maps quiz question to API response (simplified for this context)\n */\nconst mapQuizQuestionToApiResponse = (question: QuizQuestion) => ({\n  id: question.id,\n  sectionId: question.sectionId,\n  questionKey: question.questionKey,\n  questionType: question.questionType,\n  questionText: question.questionText,\n  options: question.options,\n  correctAnswer: question.correctAnswer,\n  explanation: question.explanation,\n  orderIndex: question.orderIndex,\n  isPublished: question.isPublished,\n  createdAt: question.createdAt.toISOString(),\n  updatedAt: question.updatedAt.toISOString(),\n});\n\n// =============================================================================\n// SECTION ORDERING MAPPERS\n// =============================================================================\n\n/**\n * Section ordering result\n */\nexport interface SectionOrderingResult {\n  sections: CourseSectionSchema[];\n  reordered: boolean;\n  conflicts: Array<{\n    sectionId: string;\n    sectionKey: string;\n    conflict: string;\n  }>;\n}\n\n/**\n * Validates and applies section ordering\n */\nexport const validateAndApplySectionOrdering = (\n  sections: CourseSection[],\n  newOrder: Array<{ sectionId: string; orderIndex: number }>\n): SectionOrderingResult => {\n  const sectionMap = new Map(sections.map(s => [s.id, s]));\n  const conflicts: Array<{\n    sectionId: string;\n    sectionKey: string;\n    conflict: string;\n  }> = [];\n  const reorderedSections: CourseSection[] = [];\n\n  // Check for conflicts\n  const usedIndices = new Set<number>();\n  for (const orderItem of newOrder) {\n    const section = sectionMap.get(orderItem.sectionId);\n    if (!section) {\n      conflicts.push({\n        sectionId: orderItem.sectionId,\n        sectionKey: \"\",\n        conflict: \"Section not found\",\n      });\n      continue;\n    }\n\n    if (usedIndices.has(orderItem.orderIndex)) {\n      conflicts.push({\n        sectionId: orderItem.sectionId,\n        sectionKey: section.sectionKey,\n        conflict: \"Duplicate order index\",\n      });\n    } else {\n      usedIndices.add(orderItem.orderIndex);\n      reorderedSections.push({\n        ...section,\n        orderIndex: orderItem.orderIndex,\n        updatedAt: new Date(),\n      });\n    }\n  }\n\n  return {\n    sections: mapCourseSectionsToApiResponses(reorderedSections),\n    reordered: conflicts.length === 0,\n    conflicts,\n  };\n};\n\n// =============================================================================\n// SECTION ACCESS VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * Section access validation result\n */\nexport interface SectionAccessResult {\n  hasAccess: boolean;\n  section?: CourseSectionSchema;\n  reason?: string;\n  permissions?: {\n    canView: boolean;\n    canEdit: boolean;\n    canDelete: boolean;\n    canManageContent: boolean;\n  };\n}\n\n/**\n * Validates section access based on user role and course access\n */\nexport const validateSectionAccess = (\n  section: CourseSection,\n  userRole: string,\n  courseAccess: boolean\n): SectionAccessResult => {\n  if (!courseAccess) {\n    return {\n      hasAccess: false,\n      reason: \"User does not have access to the course\",\n    };\n  }\n\n  // Safety admins can access all sections\n  if (userRole === \"safety_admin\") {\n    return {\n      hasAccess: true,\n      section: mapCourseSectionToApiResponse(section),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n        canManageContent: true,\n      },\n    };\n  }\n\n  // Plant managers can access sections in their plant\n  if (userRole === \"plant_manager\") {\n    return {\n      hasAccess: true,\n      section: mapCourseSectionToApiResponse(section),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n        canManageContent: true,\n      },\n    };\n  }\n\n  // Safety instructors can manage sections in their plant\n  if (userRole === \"safety_instructor\") {\n    return {\n      hasAccess: true,\n      section: mapCourseSectionToApiResponse(section),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: false,\n        canManageContent: true,\n      },\n    };\n  }\n\n  // HR admins can view sections and manage content in their plant\n  if (userRole === \"hr_admin\") {\n    return {\n      hasAccess: true,\n      section: mapCourseSectionToApiResponse(section),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n        canManageContent: true,\n      },\n    };\n  }\n\n  // Employees can view published sections\n  if (userRole === \"employee\") {\n    return {\n      hasAccess: section.isPublished,\n      section: section.isPublished\n        ? mapCourseSectionToApiResponse(section)\n        : undefined,\n      permissions: {\n        canView: section.isPublished,\n        canEdit: false,\n        canDelete: false,\n        canManageContent: false,\n      },\n    };\n  }\n\n  return {\n    hasAccess: false,\n    reason: \"User does not have access to this section\",\n  };\n};\n\n// =============================================================================\n// TYPE EXPORTS\n// =============================================================================\n\nexport type { SectionOrderingResult, SectionAccessResult };\n","import { ContentBlock, NewContentBlock } from \"../db/schema/content-blocks\";\nimport { CourseSection } from \"../db/schema/course-sections\";\nimport {\n  ContentBlock as ContentBlockSchema,\n  CreateContentBlockRequest,\n  UpdateContentBlockRequest,\n  ContentBlockType,\n} from \"@specchem/contracts\";\n\n/**\n * Content Block Data Mappers\n * Handles transformation between content block database entities and API responses\n */\n\n// =============================================================================\n// CONTENT BLOCK DATABASE  API RESPONSE MAPPERS\n// =============================================================================\n\n/**\n * Maps content block database entity to API response\n */\nexport const mapContentBlockToApiResponse = (\n  block: ContentBlock\n): ContentBlockSchema => ({\n  id: block.id,\n  sectionId: block.sectionId,\n  blockType: block.blockType as ContentBlockType,\n  orderIndex: block.orderIndex,\n  content: block.content,\n  metadata: block.metadata,\n  createdAt: block.createdAt.toISOString(),\n  updatedAt: block.updatedAt.toISOString(),\n});\n\n/**\n * Maps multiple content blocks to API responses\n */\nexport const mapContentBlocksToApiResponses = (\n  blocks: ContentBlock[]\n): ContentBlockSchema[] => blocks.map(mapContentBlockToApiResponse);\n\n// =============================================================================\n// API REQUEST  CONTENT BLOCK DATABASE MAPPERS\n// =============================================================================\n\n/**\n * Maps create content block API request to database entity\n */\nexport const mapCreateContentBlockRequestToDb = (\n  request: CreateContentBlockRequest,\n  sectionId: string\n): NewContentBlock => ({\n  sectionId,\n  blockType: request.blockType,\n  orderIndex: request.orderIndex,\n  content: request.content,\n  metadata: request.metadata,\n});\n\n/**\n * Maps update content block API request to database entity\n */\nexport const mapUpdateContentBlockRequestToDb = (\n  request: UpdateContentBlockRequest,\n  existingBlock: ContentBlock\n): Partial<ContentBlock> => ({\n  ...existingBlock,\n  blockType: request.blockType ?? existingBlock.blockType,\n  orderIndex: request.orderIndex ?? existingBlock.orderIndex,\n  content: request.content ?? existingBlock.content,\n  metadata: request.metadata ?? existingBlock.metadata,\n  updatedAt: new Date(),\n});\n\n// =============================================================================\n// CONTENT BLOCK TYPE-SPECIFIC MAPPERS\n// =============================================================================\n\n/**\n * Content block type-specific content structure\n */\nexport interface ContentBlockContent {\n  title?: string;\n  subtitle?: string;\n  content?: string;\n  text?: string;\n  image?: {\n    url: string;\n    alt: string;\n    caption?: string;\n  };\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n  list?: {\n    type: \"ordered\" | \"unordered\";\n    items: string[];\n  };\n  grid?: {\n    columns: number;\n    items: Array<{\n      title: string;\n      content: string;\n      image?: string;\n    }>;\n  };\n  callout?: {\n    type: \"info\" | \"warning\" | \"success\" | \"error\";\n    title: string;\n    content: string;\n  };\n  quote?: {\n    text: string;\n    author?: string;\n    source?: string;\n  };\n  video?: {\n    url: string;\n    title: string;\n    duration?: number;\n    thumbnail?: string;\n  };\n  audio?: {\n    url: string;\n    title: string;\n    duration?: number;\n  };\n}\n\n/**\n * Validates content block content based on block type\n */\nexport const validateContentBlockContent = (\n  blockType: ContentBlockType,\n  content: Record<string, unknown>\n): { isValid: boolean; errors: string[] } => {\n  const errors: string[] = [];\n\n  switch (blockType) {\n    case \"hero\":\n      if (!content.title) errors.push(\"Hero blocks require a title\");\n      break;\n\n    case \"text\":\n      if (!content.content && !content.text) {\n        errors.push(\"Text blocks require content or text\");\n      }\n      break;\n\n    case \"image\":\n      if (!content.image?.url) {\n        errors.push(\"Image blocks require an image URL\");\n      }\n      break;\n\n    case \"table\":\n      if (!content.table?.headers || !content.table?.rows) {\n        errors.push(\"Table blocks require headers and rows\");\n      }\n      break;\n\n    case \"list\":\n      if (!content.list?.items || !Array.isArray(content.list.items)) {\n        errors.push(\"List blocks require items array\");\n      }\n      break;\n\n    case \"callout\":\n      if (!content.callout?.type || !content.callout?.content) {\n        errors.push(\"Callout blocks require type and content\");\n      }\n      break;\n\n    case \"quote\":\n      if (!content.quote?.text) {\n        errors.push(\"Quote blocks require text\");\n      }\n      break;\n\n    case \"video\":\n      if (!content.video?.url) {\n        errors.push(\"Video blocks require a video URL\");\n      }\n      break;\n\n    case \"audio\":\n      if (!content.audio?.url) {\n        errors.push(\"Audio blocks require an audio URL\");\n      }\n      break;\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n/**\n * Normalizes content block content based on block type\n */\nexport const normalizeContentBlockContent = (\n  blockType: ContentBlockType,\n  content: Record<string, unknown>\n): Record<string, unknown> => {\n  const normalized = { ...content };\n\n  switch (blockType) {\n    case \"hero\":\n      // Ensure hero has required fields\n      if (!normalized.title) normalized.title = \"\";\n      if (!normalized.subtitle) normalized.subtitle = \"\";\n      break;\n\n    case \"text\":\n      // Normalize text content\n      if (normalized.text && !normalized.content) {\n        normalized.content = normalized.text;\n      }\n      break;\n\n    case \"image\":\n      // Ensure image has required structure\n      if (typeof normalized.image === \"string\") {\n        normalized.image = {\n          url: normalized.image,\n          alt: \"\",\n        };\n      }\n      break;\n\n    case \"table\":\n      // Ensure table has proper structure\n      if (!normalized.table) {\n        normalized.table = {\n          headers: [],\n          rows: [],\n        };\n      }\n      break;\n\n    case \"list\":\n      // Ensure list has proper structure\n      if (!normalized.list) {\n        normalized.list = {\n          type: \"unordered\",\n          items: [],\n        };\n      }\n      break;\n\n    case \"callout\":\n      // Ensure callout has proper structure\n      if (!normalized.callout) {\n        normalized.callout = {\n          type: \"info\",\n          title: \"\",\n          content: \"\",\n        };\n      }\n      break;\n\n    case \"quote\":\n      // Ensure quote has proper structure\n      if (!normalized.quote) {\n        normalized.quote = {\n          text: \"\",\n        };\n      }\n      break;\n\n    case \"video\":\n      // Ensure video has proper structure\n      if (!normalized.video) {\n        normalized.video = {\n          url: \"\",\n          title: \"\",\n        };\n      }\n      break;\n\n    case \"audio\":\n      // Ensure audio has proper structure\n      if (!normalized.audio) {\n        normalized.audio = {\n          url: \"\",\n          title: \"\",\n        };\n      }\n      break;\n  }\n\n  return normalized;\n};\n\n// =============================================================================\n// CONTENT BLOCK ORDERING MAPPERS\n// =============================================================================\n\n/**\n * Content block ordering result\n */\nexport interface ContentBlockOrderingResult {\n  blocks: ContentBlockSchema[];\n  reordered: boolean;\n  conflicts: Array<{\n    blockId: string;\n    conflict: string;\n  }>;\n}\n\n/**\n * Validates and applies content block ordering\n */\nexport const validateAndApplyContentBlockOrdering = (\n  blocks: ContentBlock[],\n  newOrder: Array<{ blockId: string; orderIndex: number }>\n): ContentBlockOrderingResult => {\n  const blockMap = new Map(blocks.map(b => [b.id, b]));\n  const conflicts: Array<{ blockId: string; conflict: string }> = [];\n  const reorderedBlocks: ContentBlock[] = [];\n\n  // Check for conflicts\n  const usedIndices = new Set<number>();\n  for (const orderItem of newOrder) {\n    const block = blockMap.get(orderItem.blockId);\n    if (!block) {\n      conflicts.push({\n        blockId: orderItem.blockId,\n        conflict: \"Content block not found\",\n      });\n      continue;\n    }\n\n    if (usedIndices.has(orderItem.orderIndex)) {\n      conflicts.push({\n        blockId: orderItem.blockId,\n        conflict: \"Duplicate order index\",\n      });\n    } else {\n      usedIndices.add(orderItem.orderIndex);\n      reorderedBlocks.push({\n        ...block,\n        orderIndex: orderItem.orderIndex,\n        updatedAt: new Date(),\n      });\n    }\n  }\n\n  return {\n    blocks: mapContentBlocksToApiResponses(reorderedBlocks),\n    reordered: conflicts.length === 0,\n    conflicts,\n  };\n};\n\n// =============================================================================\n// CONTENT BLOCK ACCESS VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * Content block access validation result\n */\nexport interface ContentBlockAccessResult {\n  hasAccess: boolean;\n  block?: ContentBlockSchema;\n  reason?: string;\n  permissions?: {\n    canView: boolean;\n    canEdit: boolean;\n    canDelete: boolean;\n  };\n}\n\n/**\n * Validates content block access based on user role and section access\n */\nexport const validateContentBlockAccess = (\n  block: ContentBlock,\n  userRole: string,\n  sectionAccess: boolean\n): ContentBlockAccessResult => {\n  if (!sectionAccess) {\n    return {\n      hasAccess: false,\n      reason: \"User does not have access to the section\",\n    };\n  }\n\n  // Safety admins can access all content blocks\n  if (userRole === \"safety_admin\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n      },\n    };\n  }\n\n  // Plant managers can access content blocks in their plant\n  if (userRole === \"plant_manager\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n      },\n    };\n  }\n\n  // Safety instructors can manage content blocks in their plant\n  if (userRole === \"safety_instructor\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: false,\n      },\n    };\n  }\n\n  // HR admins can view content blocks in their plant\n  if (userRole === \"hr_admin\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n      },\n    };\n  }\n\n  // Employees can view content blocks (access controlled by section)\n  if (userRole === \"employee\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n      },\n    };\n  }\n\n  return {\n    hasAccess: false,\n    reason: \"User does not have access to this content block\",\n  };\n};\n\n// =============================================================================\n// CONTENT BLOCK FILTERING MAPPERS\n// =============================================================================\n\n/**\n * Content block filtering criteria\n */\nexport interface ContentBlockFilterCriteria {\n  blockType?: ContentBlockType;\n  sectionId?: string;\n  hasContent?: boolean;\n  hasMetadata?: boolean;\n}\n\n/**\n * Maps filtering criteria to database query filters\n */\nexport const mapContentBlockFilterCriteriaToDbFilters = (\n  criteria: ContentBlockFilterCriteria\n): any => {\n  const where: any = {};\n\n  if (criteria.blockType) {\n    where.blockType = criteria.blockType;\n  }\n\n  if (criteria.sectionId) {\n    where.sectionId = criteria.sectionId;\n  }\n\n  if (criteria.hasContent !== undefined) {\n    if (criteria.hasContent) {\n      where.content = { not: null };\n    } else {\n      where.content = null;\n    }\n  }\n\n  if (criteria.hasMetadata !== undefined) {\n    if (criteria.hasMetadata) {\n      where.metadata = { not: null };\n    } else {\n      where.metadata = null;\n    }\n  }\n\n  return where;\n};\n\n// =============================================================================\n// TYPE EXPORTS\n// =============================================================================\n\nexport type {\n  ContentBlockContent,\n  ContentBlockOrderingResult,\n  ContentBlockAccessResult,\n  ContentBlockFilterCriteria,\n};\n","import { QuizQuestion, NewQuizQuestion } from \"../db/schema/quiz-questions\";\nimport { QuizAttempt } from \"../db/schema/quiz-attempts\";\nimport {\n  QuizQuestion as QuizQuestionSchema,\n  CreateQuizQuestionRequest,\n  UpdateQuizQuestionRequest,\n  SubmitQuizAnswerRequest,\n  QuizAttempt as QuizAttemptSchema,\n  QuestionType,\n} from \"@specchem/contracts\";\n\n/**\n * Quiz Question Data Mappers\n * Handles transformation between quiz question database entities and API responses\n */\n\n// =============================================================================\n// QUIZ QUESTION DATABASE  API RESPONSE MAPPERS\n// =============================================================================\n\n/**\n * Maps quiz question database entity to API response\n */\nexport const mapQuizQuestionToApiResponse = (\n  question: QuizQuestion\n): QuizQuestionSchema => ({\n  id: question.id,\n  sectionId: question.sectionId,\n  questionKey: question.questionKey,\n  questionType: question.questionType as QuestionType,\n  questionText: question.questionText,\n  options: question.options,\n  correctAnswer: question.correctAnswer,\n  explanation: question.explanation,\n  orderIndex: question.orderIndex,\n  isPublished: question.isPublished,\n  createdAt: question.createdAt.toISOString(),\n  updatedAt: question.updatedAt.toISOString(),\n});\n\n/**\n * Maps multiple quiz questions to API responses\n */\nexport const mapQuizQuestionsToApiResponses = (\n  questions: QuizQuestion[]\n): QuizQuestionSchema[] => questions.map(mapQuizQuestionToApiResponse);\n\n// =============================================================================\n// API REQUEST  QUIZ QUESTION DATABASE MAPPERS\n// =============================================================================\n\n/**\n * Maps create quiz question API request to database entity\n */\nexport const mapCreateQuizQuestionRequestToDb = (\n  request: CreateQuizQuestionRequest,\n  sectionId: string\n): NewQuizQuestion => ({\n  sectionId,\n  questionKey: request.questionKey,\n  questionType: request.questionType,\n  questionText: request.questionText,\n  options: request.options,\n  correctAnswer: request.correctAnswer,\n  explanation: request.explanation,\n  orderIndex: request.orderIndex,\n  isPublished: request.isPublished,\n});\n\n/**\n * Maps update quiz question API request to database entity\n */\nexport const mapUpdateQuizQuestionRequestToDb = (\n  request: UpdateQuizQuestionRequest,\n  existingQuestion: QuizQuestion\n): Partial<QuizQuestion> => ({\n  ...existingQuestion,\n  questionKey: request.questionKey ?? existingQuestion.questionKey,\n  questionType: request.questionType ?? existingQuestion.questionType,\n  questionText: request.questionText ?? existingQuestion.questionText,\n  options: request.options ?? existingQuestion.options,\n  correctAnswer: request.correctAnswer ?? existingQuestion.correctAnswer,\n  explanation: request.explanation ?? existingQuestion.explanation,\n  orderIndex: request.orderIndex ?? existingQuestion.orderIndex,\n  isPublished: request.isPublished ?? existingQuestion.isPublished,\n  updatedAt: new Date(),\n});\n\n// =============================================================================\n// QUIZ ANSWER VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * Quiz answer validation result\n */\nexport interface QuizAnswerValidationResult {\n  isValid: boolean;\n  isCorrect: boolean;\n  errors: string[];\n  explanation?: string;\n}\n\n/**\n * Validates quiz answer based on question type and correct answer\n */\nexport const validateQuizAnswer = (\n  question: QuizQuestion,\n  userAnswer: string | boolean | number\n): QuizAnswerValidationResult => {\n  const errors: string[] = [];\n\n  // Validate answer format based on question type\n  switch (question.questionType) {\n    case \"true-false\":\n      if (typeof userAnswer !== \"boolean\") {\n        errors.push(\"True/false questions require a boolean answer\");\n      }\n      break;\n\n    case \"multiple-choice\":\n      if (typeof userAnswer !== \"string\") {\n        errors.push(\"Multiple choice questions require a string answer\");\n      } else if (question.options && !(userAnswer in question.options)) {\n        errors.push(\"Answer must be one of the provided options\");\n      }\n      break;\n  }\n\n  if (errors.length > 0) {\n    return {\n      isValid: false,\n      isCorrect: false,\n      errors,\n    };\n  }\n\n  // Check if answer is correct\n  const isCorrect = userAnswer === question.correctAnswer;\n\n  return {\n    isValid: true,\n    isCorrect,\n    errors: [],\n    explanation: question.explanation,\n  };\n};\n\n/**\n * Maps quiz answer submission to quiz attempt\n */\nexport const mapQuizAnswerSubmissionToAttempt = (\n  request: SubmitQuizAnswerRequest,\n  userId: string,\n  isCorrect: boolean\n): Partial<QuizAttempt> => ({\n  userId,\n  quizQuestionId: request.quizQuestionId,\n  userAnswer: request.userAnswer,\n  isCorrect,\n  timeSpentSeconds: request.timeSpentSeconds,\n  attemptedAt: new Date(),\n});\n\n// =============================================================================\n// QUIZ ATTEMPT MAPPERS\n// =============================================================================\n\n/**\n * Maps quiz attempt database entity to API response\n */\nexport const mapQuizAttemptToApiResponse = (\n  attempt: QuizAttempt\n): QuizAttemptSchema => ({\n  id: attempt.id,\n  userId: attempt.userId,\n  quizQuestionId: attempt.quizQuestionId,\n  userAnswer: attempt.userAnswer,\n  isCorrect: attempt.isCorrect,\n  attemptedAt: attempt.attemptedAt.toISOString(),\n  timeSpentSeconds: attempt.timeSpentSeconds,\n});\n\n/**\n * Maps multiple quiz attempts to API responses\n */\nexport const mapQuizAttemptsToApiResponses = (\n  attempts: QuizAttempt[]\n): QuizAttemptSchema[] => attempts.map(mapQuizAttemptToApiResponse);\n\n// =============================================================================\n// QUIZ QUESTION ORDERING MAPPERS\n// =============================================================================\n\n/**\n * Quiz question ordering result\n */\nexport interface QuizQuestionOrderingResult {\n  questions: QuizQuestionSchema[];\n  reordered: boolean;\n  conflicts: Array<{\n    questionId: string;\n    questionKey: string;\n    conflict: string;\n  }>;\n}\n\n/**\n * Validates and applies quiz question ordering\n */\nexport const validateAndApplyQuizQuestionOrdering = (\n  questions: QuizQuestion[],\n  newOrder: Array<{ questionId: string; orderIndex: number }>\n): QuizQuestionOrderingResult => {\n  const questionMap = new Map(questions.map(q => [q.id, q]));\n  const conflicts: Array<{\n    questionId: string;\n    questionKey: string;\n    conflict: string;\n  }> = [];\n  const reorderedQuestions: QuizQuestion[] = [];\n\n  // Check for conflicts\n  const usedIndices = new Set<number>();\n  for (const orderItem of newOrder) {\n    const question = questionMap.get(orderItem.questionId);\n    if (!question) {\n      conflicts.push({\n        questionId: orderItem.questionId,\n        questionKey: \"\",\n        conflict: \"Quiz question not found\",\n      });\n      continue;\n    }\n\n    if (usedIndices.has(orderItem.orderIndex)) {\n      conflicts.push({\n        questionId: orderItem.questionId,\n        questionKey: question.questionKey,\n        conflict: \"Duplicate order index\",\n      });\n    } else {\n      usedIndices.add(orderItem.orderIndex);\n      reorderedQuestions.push({\n        ...question,\n        orderIndex: orderItem.orderIndex,\n        updatedAt: new Date(),\n      });\n    }\n  }\n\n  return {\n    questions: mapQuizQuestionsToApiResponses(reorderedQuestions),\n    reordered: conflicts.length === 0,\n    conflicts,\n  };\n};\n\n// =============================================================================\n// QUIZ QUESTION ACCESS VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * Quiz question access validation result\n */\nexport interface QuizQuestionAccessResult {\n  hasAccess: boolean;\n  question?: QuizQuestionSchema;\n  reason?: string;\n  permissions?: {\n    canView: boolean;\n    canEdit: boolean;\n    canDelete: boolean;\n    canSubmitAnswer: boolean;\n  };\n}\n\n/**\n * Validates quiz question access based on user role and section access\n */\nexport const validateQuizQuestionAccess = (\n  question: QuizQuestion,\n  userRole: string,\n  sectionAccess: boolean\n): QuizQuestionAccessResult => {\n  if (!sectionAccess) {\n    return {\n      hasAccess: false,\n      reason: \"User does not have access to the section\",\n    };\n  }\n\n  // Safety admins can access all quiz questions\n  if (userRole === \"safety_admin\") {\n    return {\n      hasAccess: true,\n      question: mapQuizQuestionToApiResponse(question),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n        canSubmitAnswer: true,\n      },\n    };\n  }\n\n  // Plant managers can access quiz questions in their plant\n  if (userRole === \"plant_manager\") {\n    return {\n      hasAccess: true,\n      question: mapQuizQuestionToApiResponse(question),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n        canSubmitAnswer: true,\n      },\n    };\n  }\n\n  // Safety instructors can manage quiz questions in their plant\n  if (userRole === \"safety_instructor\") {\n    return {\n      hasAccess: true,\n      question: mapQuizQuestionToApiResponse(question),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: false,\n        canSubmitAnswer: true,\n      },\n    };\n  }\n\n  // HR admins can view quiz questions in their plant\n  if (userRole === \"hr_admin\") {\n    return {\n      hasAccess: true,\n      question: mapQuizQuestionToApiResponse(question),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n        canSubmitAnswer: true,\n      },\n    };\n  }\n\n  // Employees can view and answer published quiz questions\n  if (userRole === \"employee\") {\n    return {\n      hasAccess: question.isPublished,\n      question: question.isPublished\n        ? mapQuizQuestionToApiResponse(question)\n        : undefined,\n      permissions: {\n        canView: question.isPublished,\n        canEdit: false,\n        canDelete: false,\n        canSubmitAnswer: question.isPublished,\n      },\n    };\n  }\n\n  return {\n    hasAccess: false,\n    reason: \"User does not have access to this quiz question\",\n  };\n};\n\n// =============================================================================\n// QUIZ STATISTICS MAPPERS\n// =============================================================================\n\n/**\n * Quiz question statistics\n */\nexport interface QuizQuestionStatistics {\n  question: QuizQuestionSchema;\n  totalAttempts: number;\n  correctAttempts: number;\n  incorrectAttempts: number;\n  averageTimeSpent: number;\n  successRate: number;\n  lastAttempted?: string;\n}\n\n/**\n * Maps quiz question to statistics response\n */\nexport const mapQuizQuestionToStatistics = (\n  question: QuizQuestion,\n  attempts: QuizAttempt[]\n): QuizQuestionStatistics => {\n  const totalAttempts = attempts.length;\n  const correctAttempts = attempts.filter(a => a.isCorrect).length;\n  const incorrectAttempts = totalAttempts - correctAttempts;\n  const averageTimeSpent =\n    totalAttempts > 0\n      ? attempts.reduce((sum, a) => sum + a.timeSpentSeconds, 0) / totalAttempts\n      : 0;\n  const successRate =\n    totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0;\n  const lastAttempted =\n    attempts.length > 0\n      ? attempts\n          .sort((a, b) => b.attemptedAt.getTime() - a.attemptedAt.getTime())[0]\n          .attemptedAt.toISOString()\n      : undefined;\n\n  return {\n    question: mapQuizQuestionToApiResponse(question),\n    totalAttempts,\n    correctAttempts,\n    incorrectAttempts,\n    averageTimeSpent,\n    successRate,\n    lastAttempted,\n  };\n};\n\n// =============================================================================\n// QUIZ QUESTION FILTERING MAPPERS\n// =============================================================================\n\n/**\n * Quiz question filtering criteria\n */\nexport interface QuizQuestionFilterCriteria {\n  questionType?: QuestionType;\n  sectionId?: string;\n  isPublished?: boolean;\n  hasOptions?: boolean;\n  hasExplanation?: boolean;\n}\n\n/**\n * Maps filtering criteria to database query filters\n */\nexport const mapQuizQuestionFilterCriteriaToDbFilters = (\n  criteria: QuizQuestionFilterCriteria\n): any => {\n  const where: any = {};\n\n  if (criteria.questionType) {\n    where.questionType = criteria.questionType;\n  }\n\n  if (criteria.sectionId) {\n    where.sectionId = criteria.sectionId;\n  }\n\n  if (criteria.isPublished !== undefined) {\n    where.isPublished = criteria.isPublished;\n  }\n\n  if (criteria.hasOptions !== undefined) {\n    if (criteria.hasOptions) {\n      where.options = { not: null };\n    } else {\n      where.options = null;\n    }\n  }\n\n  if (criteria.hasExplanation !== undefined) {\n    if (criteria.hasExplanation) {\n      where.explanation = { not: null };\n    } else {\n      where.explanation = null;\n    }\n  }\n\n  return where;\n};\n\n// =============================================================================\n// TYPE EXPORTS\n// =============================================================================\n\nexport type {\n  QuizAnswerValidationResult,\n  QuizQuestionOrderingResult,\n  QuizQuestionAccessResult,\n  QuizQuestionStatistics,\n  QuizQuestionFilterCriteria,\n};\n","import { UserProgress, NewUserProgress } from \"../db/schema/user-progress\";\nimport { CourseSection } from \"../db/schema/course-sections\";\nimport { Course } from \"../db/schema/courses\";\nimport {\n  UserProgress as UserProgressSchema,\n  UpdateUserProgressRequest,\n  CourseCompletionStatusResponse,\n} from \"@specchem/contracts\";\n\n/**\n * User Progress Data Mappers\n * Handles transformation between user progress database entities and API responses\n */\n\n// =============================================================================\n// USER PROGRESS DATABASE  API RESPONSE MAPPERS\n// =============================================================================\n\n/**\n * Maps user progress database entity to API response\n */\nexport const mapUserProgressToApiResponse = (\n  progress: UserProgress\n): UserProgressSchema => ({\n  id: progress.id,\n  userId: progress.userId,\n  courseId: progress.courseId,\n  sectionId: progress.sectionId,\n  isCompleted: progress.isCompleted,\n  completionPercentage: progress.completionPercentage,\n  timeSpentSeconds: progress.timeSpentSeconds,\n  lastAccessedAt: progress.lastAccessedAt.toISOString(),\n  completedAt: progress.completedAt?.toISOString(),\n  createdAt: progress.createdAt.toISOString(),\n  updatedAt: progress.updatedAt.toISOString(),\n});\n\n/**\n * Maps multiple user progress records to API responses\n */\nexport const mapUserProgressToApiResponses = (\n  progressRecords: UserProgress[]\n): UserProgressSchema[] => progressRecords.map(mapUserProgressToApiResponse);\n\n// =============================================================================\n// API REQUEST  USER PROGRESS DATABASE MAPPERS\n// =============================================================================\n\n/**\n * Maps update user progress API request to database entity\n */\nexport const mapUpdateUserProgressRequestToDb = (\n  request: UpdateUserProgressRequest,\n  userId: string,\n  existingProgress?: UserProgress\n): Partial<UserProgress> => {\n  const now = new Date();\n\n  return {\n    ...existingProgress,\n    userId,\n    courseId: request.courseId,\n    sectionId: request.sectionId,\n    isCompleted: request.isCompleted ?? existingProgress?.isCompleted ?? false,\n    completionPercentage:\n      request.completionPercentage ??\n      existingProgress?.completionPercentage ??\n      0,\n    timeSpentSeconds:\n      request.timeSpentSeconds ?? existingProgress?.timeSpentSeconds ?? 0,\n    lastAccessedAt: now,\n    completedAt: request.isCompleted ? now : existingProgress?.completedAt,\n    updatedAt: now,\n  };\n};\n\n/**\n * Creates new user progress record\n */\nexport const mapCreateUserProgressRequestToDb = (\n  request: UpdateUserProgressRequest,\n  userId: string\n): NewUserProgress => {\n  const now = new Date();\n\n  return {\n    userId,\n    courseId: request.courseId,\n    sectionId: request.sectionId,\n    isCompleted: request.isCompleted ?? false,\n    completionPercentage: request.completionPercentage ?? 0,\n    timeSpentSeconds: request.timeSpentSeconds ?? 0,\n    lastAccessedAt: now,\n    completedAt: request.isCompleted ? now : undefined,\n  };\n};\n\n// =============================================================================\n// COURSE COMPLETION STATUS MAPPERS\n// =============================================================================\n\n/**\n * Course completion status data\n */\nexport interface CourseCompletionStatusData {\n  courseId: string;\n  userId: string;\n  totalSections: number;\n  completedSections: number;\n  completionPercentage: number;\n  timeSpentSeconds: number;\n  lastAccessedAt: Date;\n  completedAt?: Date;\n}\n\n/**\n * Maps course completion status to API response\n */\nexport const mapCourseCompletionStatusToApiResponse = (\n  status: CourseCompletionStatusData\n): CourseCompletionStatusResponse[\"data\"] => ({\n  courseId: status.courseId,\n  userId: status.userId,\n  totalSections: status.totalSections,\n  completedSections: status.completedSections,\n  completionPercentage: status.completionPercentage,\n  timeSpentSeconds: status.timeSpentSeconds,\n  lastAccessedAt: status.lastAccessedAt.toISOString(),\n  completedAt: status.completedAt?.toISOString(),\n});\n\n/**\n * Calculates course completion status from progress records\n */\nexport const calculateCourseCompletionStatus = (\n  progressRecords: UserProgress[],\n  courseId: string,\n  userId: string,\n  totalSections: number\n): CourseCompletionStatusData => {\n  const courseProgress = progressRecords.filter(\n    p => p.courseId === courseId && p.userId === userId\n  );\n\n  const completedSections = courseProgress.filter(p => p.isCompleted).length;\n  const completionPercentage =\n    totalSections > 0\n      ? Math.round((completedSections / totalSections) * 100)\n      : 0;\n  const timeSpentSeconds = courseProgress.reduce(\n    (sum, p) => sum + p.timeSpentSeconds,\n    0\n  );\n\n  const lastAccessedAt =\n    courseProgress.length > 0\n      ? courseProgress.reduce(\n          (latest, p) =>\n            p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n          courseProgress[0].lastAccessedAt\n        )\n      : new Date();\n\n  const completedAt =\n    completedSections === totalSections && totalSections > 0\n      ? courseProgress.reduce(\n          (latest, p) =>\n            p.completedAt && p.completedAt > latest ? p.completedAt : latest,\n          courseProgress[0].completedAt || new Date(0)\n        )\n      : undefined;\n\n  return {\n    courseId,\n    userId,\n    totalSections,\n    completedSections,\n    completionPercentage,\n    timeSpentSeconds,\n    lastAccessedAt,\n    completedAt:\n      completedAt && completedAt.getTime() > 0 ? completedAt : undefined,\n  };\n};\n\n// =============================================================================\n// PROGRESS TRACKING MAPPERS\n// =============================================================================\n\n/**\n * Progress tracking event data\n */\nexport interface ProgressTrackingEvent {\n  userId: string;\n  courseId: string;\n  sectionId: string;\n  eventType: \"started\" | \"progressed\" | \"completed\" | \"paused\" | \"resumed\";\n  completionPercentage: number;\n  timeSpentSeconds: number;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Maps progress tracking event to user progress update\n */\nexport const mapProgressTrackingEventToProgressUpdate = (\n  event: ProgressTrackingEvent,\n  existingProgress?: UserProgress\n): Partial<UserProgress> => {\n  const now = new Date();\n  const isCompleted =\n    event.eventType === \"completed\" || event.completionPercentage >= 100;\n\n  return {\n    ...existingProgress,\n    userId: event.userId,\n    courseId: event.courseId,\n    sectionId: event.sectionId,\n    isCompleted,\n    completionPercentage: Math.min(event.completionPercentage, 100),\n    timeSpentSeconds: event.timeSpentSeconds,\n    lastAccessedAt: now,\n    completedAt: isCompleted ? now : existingProgress?.completedAt,\n    updatedAt: now,\n  };\n};\n\n// =============================================================================\n// PROGRESS ANALYTICS MAPPERS\n// =============================================================================\n\n/**\n * User progress analytics data\n */\nexport interface UserProgressAnalytics {\n  userId: string;\n  totalCourses: number;\n  completedCourses: number;\n  inProgressCourses: number;\n  totalTimeSpent: number;\n  averageCompletionRate: number;\n  lastActivity?: string;\n  coursesByStatus: {\n    completed: string[];\n    inProgress: string[];\n    notStarted: string[];\n  };\n}\n\n/**\n * Maps user progress records to analytics data\n */\nexport const mapUserProgressToAnalytics = (\n  progressRecords: UserProgress[],\n  userId: string,\n  allCourses: Course[]\n): UserProgressAnalytics => {\n  const userProgress = progressRecords.filter(p => p.userId === userId);\n\n  // Group progress by course\n  const courseProgressMap = new Map<string, UserProgress[]>();\n  userProgress.forEach(p => {\n    const existing = courseProgressMap.get(p.courseId) || [];\n    existing.push(p);\n    courseProgressMap.set(p.courseId, existing);\n  });\n\n  const totalCourses = allCourses.length;\n  let completedCourses = 0;\n  let inProgressCourses = 0;\n  const totalTimeSpent = userProgress.reduce(\n    (sum, p) => sum + p.timeSpentSeconds,\n    0\n  );\n\n  const coursesByStatus = {\n    completed: [] as string[],\n    inProgress: [] as string[],\n    notStarted: [] as string[],\n  };\n\n  // Analyze each course\n  allCourses.forEach(course => {\n    const courseProgress = courseProgressMap.get(course.id) || [];\n    const completedSections = courseProgress.filter(p => p.isCompleted).length;\n    const totalSections = courseProgress.length;\n\n    if (totalSections === 0) {\n      coursesByStatus.notStarted.push(course.id);\n    } else if (completedSections === totalSections && totalSections > 0) {\n      completedCourses++;\n      coursesByStatus.completed.push(course.id);\n    } else {\n      inProgressCourses++;\n      coursesByStatus.inProgress.push(course.id);\n    }\n  });\n\n  const averageCompletionRate =\n    totalCourses > 0 ? (completedCourses / totalCourses) * 100 : 0;\n\n  const lastActivity =\n    userProgress.length > 0\n      ? userProgress\n          .reduce(\n            (latest, p) =>\n              p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n            userProgress[0].lastAccessedAt\n          )\n          .toISOString()\n      : undefined;\n\n  return {\n    userId,\n    totalCourses,\n    completedCourses,\n    inProgressCourses,\n    totalTimeSpent,\n    averageCompletionRate,\n    lastActivity,\n    coursesByStatus,\n  };\n};\n\n// =============================================================================\n// PROGRESS FILTERING MAPPERS\n// =============================================================================\n\n/**\n * User progress filtering criteria\n */\nexport interface UserProgressFilterCriteria {\n  userId?: string;\n  courseId?: string;\n  sectionId?: string;\n  isCompleted?: boolean;\n  completionPercentageMin?: number;\n  completionPercentageMax?: number;\n  dateFrom?: Date;\n  dateTo?: Date;\n}\n\n/**\n * Maps filtering criteria to database query filters\n */\nexport const mapUserProgressFilterCriteriaToDbFilters = (\n  criteria: UserProgressFilterCriteria\n): any => {\n  const where: any = {};\n\n  if (criteria.userId) {\n    where.userId = criteria.userId;\n  }\n\n  if (criteria.courseId) {\n    where.courseId = criteria.courseId;\n  }\n\n  if (criteria.sectionId) {\n    where.sectionId = criteria.sectionId;\n  }\n\n  if (criteria.isCompleted !== undefined) {\n    where.isCompleted = criteria.isCompleted;\n  }\n\n  if (\n    criteria.completionPercentageMin !== undefined ||\n    criteria.completionPercentageMax !== undefined\n  ) {\n    where.completionPercentage = {};\n    if (criteria.completionPercentageMin !== undefined) {\n      where.completionPercentage.gte = criteria.completionPercentageMin;\n    }\n    if (criteria.completionPercentageMax !== undefined) {\n      where.completionPercentage.lte = criteria.completionPercentageMax;\n    }\n  }\n\n  if (criteria.dateFrom || criteria.dateTo) {\n    where.lastAccessedAt = {};\n    if (criteria.dateFrom) {\n      where.lastAccessedAt.gte = criteria.dateFrom;\n    }\n    if (criteria.dateTo) {\n      where.lastAccessedAt.lte = criteria.dateTo;\n    }\n  }\n\n  return where;\n};\n\n// =============================================================================\n// PROGRESS ACCESS VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * User progress access validation result\n */\nexport interface UserProgressAccessResult {\n  hasAccess: boolean;\n  progress?: UserProgressSchema;\n  reason?: string;\n  permissions?: {\n    canView: boolean;\n    canEdit: boolean;\n    canDelete: boolean;\n  };\n}\n\n/**\n * Validates user progress access based on user role and ownership\n */\nexport const validateUserProgressAccess = (\n  progress: UserProgress,\n  userId: string,\n  userRole: string\n): UserProgressAccessResult => {\n  // Users can always access their own progress\n  if (progress.userId === userId) {\n    return {\n      hasAccess: true,\n      progress: mapUserProgressToApiResponse(progress),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: false,\n      },\n    };\n  }\n\n  // Safety admins can access all progress\n  if (userRole === \"safety_admin\") {\n    return {\n      hasAccess: true,\n      progress: mapUserProgressToApiResponse(progress),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n      },\n    };\n  }\n\n  // Plant managers can access progress in their plant\n  if (userRole === \"plant_manager\") {\n    return {\n      hasAccess: true,\n      progress: mapUserProgressToApiResponse(progress),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n      },\n    };\n  }\n\n  // HR admins can view progress in their plant\n  if (userRole === \"hr_admin\") {\n    return {\n      hasAccess: true,\n      progress: mapUserProgressToApiResponse(progress),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n      },\n    };\n  }\n\n  return {\n    hasAccess: false,\n    reason: \"User does not have access to this progress record\",\n  };\n};\n\n// =============================================================================\n// TYPE EXPORTS\n// =============================================================================\n\nexport type {\n  CourseCompletionStatusData,\n  ProgressTrackingEvent,\n  UserProgressAnalytics,\n  UserProgressFilterCriteria,\n  UserProgressAccessResult,\n};\n","import { NextRequest } from \"next/server\";\nimport { z } from \"zod\";\nimport {\n  CreateCourseSectionRequest,\n  UpdateCourseSectionRequest,\n  CourseSectionResponse,\n  CourseWithSectionsResponse,\n  SectionWithContentResponse,\n  LmsContentErrorResponse,\n} from \"@specchem/contracts\";\nimport {\n  getCourseSectionById,\n  getCourseSectionByKey,\n  getCourseSectionsByCourseId,\n  getCourseSectionWithContent,\n  createCourseSection,\n  updateCourseSection,\n  deleteCourseSection,\n  reorderSections,\n  getNextSectionOrderIndex,\n  isSectionKeyUnique,\n  isOrderIndexUnique,\n  getSectionStatistics,\n  searchCourseSections,\n  getAccessibleCourseSections,\n  canUserAccessSection,\n} from \"../db/queries/course-sections\";\nimport {\n  getContentBlocksBySectionId,\n  getContentBlocksByType,\n  createContentBlock,\n  updateContentBlock,\n  deleteContentBlock,\n  reorderContentBlocks,\n  getNextContentBlockOrderIndex,\n  isContentBlockOrderIndexUnique,\n  validateContentBlockContent,\n  getContentBlockStatistics,\n  searchContentBlocks,\n  getAccessibleContentBlocks,\n  canUserAccessContentBlock,\n} from \"../db/queries/content-blocks\";\nimport {\n  getQuizQuestionsBySectionId,\n  getQuizQuestionsByType,\n  createQuizQuestion,\n  updateQuizQuestion,\n  deleteQuizQuestion,\n  reorderQuizQuestions,\n  getNextQuizQuestionOrderIndex,\n  isQuestionKeyUnique,\n  isQuizQuestionOrderIndexUnique,\n  validateQuizQuestionContent,\n  getQuizQuestionStatistics,\n  getSectionQuizStatistics,\n  searchQuizQuestions,\n  getAccessibleQuizQuestions,\n  canUserAccessQuizQuestion,\n  createQuizAttempt,\n  getQuizAttemptsByUser,\n  getQuizAttemptsByQuestion,\n  getQuizQuestionById,\n} from \"../db/queries/quiz-questions\";\nimport {\n  getUserProgressByUser,\n  getUserProgressByUserAndSection,\n  upsertUserProgress,\n  updateUserProgress,\n  updateUserProgressByUserAndSection,\n  deleteUserProgress,\n  calculateCourseCompletionStatus,\n  getUserProgressAnalytics,\n  getCourseProgressStatistics,\n  searchUserProgress,\n  getAccessibleUserProgress,\n  canUserAccessProgress,\n} from \"../db/queries/user-progress\";\nimport {\n  mapCourseSectionToApiResponse,\n  mapCourseSectionsToApiResponses,\n  mapCreateCourseSectionRequestToDb,\n  mapUpdateCourseSectionRequestToDb,\n  mapSectionWithContentToApiResponse,\n  validateSectionAccess,\n  validateAndApplySectionOrdering,\n} from \"../mappers/course-section-mappers\";\nimport {\n  mapContentBlockToApiResponse,\n  mapContentBlocksToApiResponses,\n  mapCreateContentBlockRequestToDb,\n  mapUpdateContentBlockRequestToDb,\n  validateContentBlockAccess,\n  validateAndApplyContentBlockOrdering,\n} from \"../mappers/content-block-mappers\";\nimport {\n  mapQuizQuestionToApiResponse,\n  mapQuizQuestionsToApiResponses,\n  mapCreateQuizQuestionRequestToDb,\n  mapUpdateQuizQuestionRequestToDb,\n  validateQuizAnswer,\n  mapQuizAnswerSubmissionToAttempt,\n  mapQuizAttemptToApiResponse,\n  mapQuizAttemptsToApiResponses,\n  validateQuizQuestionAccess,\n  validateAndApplyQuizQuestionOrdering,\n} from \"../mappers/quiz-question-mappers\";\nimport {\n  mapUserProgressToApiResponse,\n  mapUserProgressToApiResponses,\n  mapUpdateUserProgressRequestToDb,\n  mapCreateUserProgressRequestToDb,\n  mapCourseCompletionStatusToApiResponse,\n  calculateCourseCompletionStatus as calculateCompletionStatus,\n  mapUserProgressToAnalytics,\n  mapProgressTrackingEventToProgressUpdate,\n  validateUserProgressAccess,\n} from \"../mappers/user-progress-mappers\";\n\n/**\n * LMS Content Service Layer\n * Handles business logic for structured course content, sections, blocks, and quizzes\n */\n\n// =============================================================================\n// COURSE SECTION SERVICES\n// =============================================================================\n\n/**\n * Get course content with sections\n */\nexport const getCourseContentService = async (\n  courseKey: string,\n  languageCode: string = \"en\",\n  includeUnpublished: boolean = false,\n  userRole: string = \"employee\"\n): Promise<CourseWithSectionsResponse | LmsContentErrorResponse> => {\n  try {\n    // Get course by key (would need to implement this query)\n    // const course = await getCourseByKey(courseKey);\n    // if (!course) {\n    //   return {\n    //     success: false,\n    //     error: {\n    //       code: \"COURSE_NOT_FOUND\",\n    //       message: \"Course not found\",\n    //       timestamp: new Date().toISOString(),\n    //     },\n    //     version: \"1.0\",\n    //   };\n    // }\n\n    // Get accessible sections\n    const sections = await getAccessibleCourseSections(courseKey, userRole, {\n      includeUnpublished,\n    });\n\n    return {\n      success: true,\n      data: {\n        course: {\n          id: courseKey, // Would be actual course ID\n          courseKey,\n          title: \"Function-Specific HazMat Training\", // Would be from course\n          description:\n            \"Handling, Packaging, and Shipping DOT-Regulated Materials\",\n          version: \"1.0\",\n          isPublished: true,\n        },\n        sections: mapCourseSectionsToApiResponses(sections),\n      },\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Get section content with blocks and quiz questions\n */\nexport const getSectionContentService = async (\n  courseKey: string,\n  sectionKey: string,\n  languageCode: string = \"en\",\n  includeUnpublished: boolean = false,\n  userRole: string = \"employee\"\n): Promise<SectionWithContentResponse | LmsContentErrorResponse> => {\n  try {\n    // Get course by key (would need to implement this query)\n    // const course = await getCourseByKey(courseKey);\n    // if (!course) {\n    //   return {\n    //     success: false,\n    //     error: {\n    //       code: \"COURSE_NOT_FOUND\",\n    //       message: \"Course not found\",\n    //       timestamp: new Date().toISOString(),\n    //     },\n    //     version: \"1.0\",\n    //   };\n    // }\n\n    // Get section by key\n    const section = await getCourseSectionByKey(courseKey, sectionKey);\n    if (!section) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateSectionAccess(section, userRole, true);\n    if (!accessResult.hasAccess) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get section with content\n    const sectionWithContent = await getCourseSectionWithContent(section.id);\n    if (!sectionWithContent) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section content not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      data: mapSectionWithContentToApiResponse(\n        sectionWithContent.section,\n        sectionWithContent.contentBlocks,\n        sectionWithContent.quizQuestions\n      ),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Create course section\n */\nexport const createCourseSectionService = async (\n  courseKey: string,\n  request: CreateCourseSectionRequest,\n  userRole: string = \"employee\"\n): Promise<CourseSectionResponse | LmsContentErrorResponse> => {\n  try {\n    // Check permissions\n    if (userRole === \"employee\") {\n      return {\n        success: false,\n        error: {\n          code: \"USER_NOT_AUTHORIZED\",\n          message: \"Insufficient permissions\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get course by key (would need to implement this query)\n    // const course = await getCourseByKey(courseKey);\n    // if (!course) {\n    //   return {\n    //     success: false,\n    //     error: {\n    //       code: \"COURSE_NOT_FOUND\",\n    //       message: \"Course not found\",\n    //       timestamp: new Date().toISOString(),\n    //     },\n    //     version: \"1.0\",\n    //   };\n    // }\n\n    // Validate section key uniqueness\n    const isKeyUnique = await isSectionKeyUnique(courseKey, request.sectionKey);\n    if (!isKeyUnique) {\n      return {\n        success: false,\n        error: {\n          code: \"VALIDATION_ERROR\",\n          message: \"Section key must be unique within the course\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get next order index if not provided\n    const orderIndex =\n      request.orderIndex ?? (await getNextSectionOrderIndex(courseKey));\n\n    // Create section\n    const sectionData = mapCreateCourseSectionRequestToDb(request, courseKey);\n    const section = await createCourseSection(sectionData);\n\n    return {\n      success: true,\n      data: mapCourseSectionToApiResponse(section),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Update course section\n */\nexport const updateCourseSectionService = async (\n  sectionId: string,\n  request: UpdateCourseSectionRequest,\n  userRole: string = \"employee\"\n): Promise<CourseSectionResponse | LmsContentErrorResponse> => {\n  try {\n    // Get existing section\n    const existingSection = await getCourseSectionById(sectionId);\n    if (!existingSection) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateSectionAccess(existingSection, userRole, true);\n    if (!accessResult.hasAccess || !accessResult.permissions?.canEdit) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Validate section key uniqueness if changing\n    if (\n      request.sectionKey &&\n      request.sectionKey !== existingSection.sectionKey\n    ) {\n      const isKeyUnique = await isSectionKeyUnique(\n        existingSection.courseId,\n        request.sectionKey,\n        sectionId\n      );\n      if (!isKeyUnique) {\n        return {\n          success: false,\n          error: {\n            code: \"VALIDATION_ERROR\",\n            message: \"Section key must be unique within the course\",\n            timestamp: new Date().toISOString(),\n          },\n          version: \"1.0\",\n        };\n      }\n    }\n\n    // Update section\n    const updates = mapUpdateCourseSectionRequestToDb(request, existingSection);\n    const updatedSection = await updateCourseSection(sectionId, updates);\n\n    if (!updatedSection) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Failed to update section\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      data: mapCourseSectionToApiResponse(updatedSection),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Delete course section\n */\nexport const deleteCourseSectionService = async (\n  sectionId: string,\n  userRole: string = \"employee\"\n): Promise<\n  { success: true; message: string; version: \"1.0\" } | LmsContentErrorResponse\n> => {\n  try {\n    // Get existing section\n    const existingSection = await getCourseSectionById(sectionId);\n    if (!existingSection) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateSectionAccess(existingSection, userRole, true);\n    if (!accessResult.hasAccess || !accessResult.permissions?.canDelete) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Delete section\n    const deleted = await deleteCourseSection(sectionId);\n    if (!deleted) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Failed to delete section\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      message: \"Section deleted successfully\",\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n// =============================================================================\n// CONTENT BLOCK SERVICES\n// =============================================================================\n\n/**\n * Create content block\n */\nexport const createContentBlockService = async (\n  sectionId: string,\n  request: any, // CreateContentBlockRequest\n  userRole: string = \"employee\"\n): Promise<any> => {\n  try {\n    // Check permissions\n    if (userRole === \"employee\") {\n      return {\n        success: false,\n        error: {\n          code: \"USER_NOT_AUTHORIZED\",\n          message: \"Insufficient permissions\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get section\n    const section = await getCourseSectionById(sectionId);\n    if (!section) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateSectionAccess(section, userRole, true);\n    if (!accessResult.hasAccess || !accessResult.permissions?.canEdit) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Validate content\n    const validation = await validateContentBlockContent(\n      request.blockType,\n      request.content\n    );\n    if (!validation.isValid) {\n      return {\n        success: false,\n        error: {\n          code: \"VALIDATION_ERROR\",\n          message: validation.errors.join(\", \"),\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get next order index if not provided\n    const orderIndex =\n      request.orderIndex ?? (await getNextContentBlockOrderIndex(sectionId));\n\n    // Create content block\n    const blockData = mapCreateContentBlockRequestToDb(request, sectionId);\n    const block = await createContentBlock(blockData);\n\n    return {\n      success: true,\n      data: mapContentBlockToApiResponse(block),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n// =============================================================================\n// QUIZ QUESTION SERVICES\n// =============================================================================\n\n/**\n * Submit quiz answer\n */\nexport const submitQuizAnswerService = async (\n  quizQuestionId: string,\n  request: any, // SubmitQuizAnswerRequest\n  userId: string,\n  userRole: string = \"employee\"\n): Promise<any> => {\n  try {\n    // Get quiz question\n    const question = await getQuizQuestionById(quizQuestionId);\n    if (!question) {\n      return {\n        success: false,\n        error: {\n          code: \"QUIZ_QUESTION_NOT_FOUND\",\n          message: \"Quiz question not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateQuizQuestionAccess(question, userRole, true);\n    if (!accessResult.hasAccess || !accessResult.permissions?.canSubmitAnswer) {\n      return {\n        success: false,\n        error: {\n          code: \"QUIZ_QUESTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Validate answer\n    const validation = validateQuizAnswer(question, request.userAnswer);\n    if (!validation.isValid) {\n      return {\n        success: false,\n        error: {\n          code: \"INVALID_QUIZ_ANSWER\",\n          message: validation.errors.join(\", \"),\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Create quiz attempt\n    const attemptData = mapQuizAnswerSubmissionToAttempt(\n      request,\n      userId,\n      validation.isCorrect\n    );\n    const attempt = await createQuizAttempt(attemptData);\n\n    return {\n      success: true,\n      data: mapQuizAttemptToApiResponse(attempt),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n// =============================================================================\n// USER PROGRESS SERVICES\n// =============================================================================\n\n/**\n * Update user progress\n */\nexport const updateUserProgressService = async (\n  userId: string,\n  request: any, // UpdateUserProgressRequest\n  userRole: string = \"employee\"\n): Promise<any> => {\n  try {\n    // Check permissions\n    if (userRole === \"employee\") {\n      return {\n        success: false,\n        error: {\n          code: \"USER_NOT_AUTHORIZED\",\n          message: \"Insufficient permissions\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get existing progress or create new\n    const existingProgress = await getUserProgressByUserAndSection(\n      userId,\n      request.sectionId\n    );\n\n    let progress;\n    if (existingProgress) {\n      const updates = mapUpdateUserProgressRequestToDb(\n        request,\n        userId,\n        existingProgress\n      );\n      progress = await updateUserProgressByUserAndSection(\n        userId,\n        request.sectionId,\n        updates\n      );\n    } else {\n      const newProgress = mapCreateUserProgressRequestToDb(request, userId);\n      progress = await upsertUserProgress(newProgress);\n    }\n\n    if (!progress) {\n      return {\n        success: false,\n        error: {\n          code: \"PROGRESS_UPDATE_FAILED\",\n          message: \"Failed to update progress\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      data: mapUserProgressToApiResponse(progress),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Get course completion status\n */\nexport const getCourseCompletionStatusService = async (\n  userId: string,\n  courseId: string,\n  userRole: string = \"employee\"\n): Promise<any> => {\n  try {\n    // Check access\n    const canAccess = await canUserAccessProgress(\"\", userId, userRole);\n    if (!canAccess) {\n      return {\n        success: false,\n        error: {\n          code: \"USER_NOT_AUTHORIZED\",\n          message: \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Calculate completion status\n    const status = await calculateCourseCompletionStatus(userId, courseId);\n    if (!status) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_NOT_FOUND\",\n          message: \"Course not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      data: mapCourseCompletionStatusToApiResponse(status),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n// =============================================================================\n// LMS CONTENT SERVICE OBJECT\n// =============================================================================\n\n/**\n * Main LMS Content Service Object\n * Provides a unified interface for all LMS content operations\n */\nexport const lmsContentService = {\n  // Course Section Services\n  getCourseSections: async (options: any) => {\n    // Simple implementation for now\n    return {\n      success: true,\n      data: [],\n      pagination: {\n        page: 1,\n        limit: 20,\n        total: 0,\n        totalPages: 0,\n        hasNext: false,\n        hasPrev: false,\n      },\n    };\n  },\n\n  createCourseSection: async (data: any) => {\n    return createCourseSectionService(\"\", data);\n  },\n\n  updateCourseSection: async (id: string, data: any) => {\n    return updateCourseSectionService(id, data);\n  },\n\n  deleteCourseSection: async (id: string) => {\n    return deleteCourseSectionService(id);\n  },\n\n  // Content Block Services\n  getContentBlocks: async (options: any) => {\n    // Simple implementation for now\n    return {\n      success: true,\n      data: [],\n      pagination: {\n        page: 1,\n        limit: 20,\n        total: 0,\n        totalPages: 0,\n        hasNext: false,\n        hasPrev: false,\n      },\n    };\n  },\n\n  createContentBlock: async (data: any) => {\n    return createContentBlockService(\"\", data);\n  },\n\n  updateContentBlock: async (id: string, data: any) => {\n    // Implementation needed\n    return {\n      success: true,\n      data: {},\n    };\n  },\n\n  deleteContentBlock: async (id: string) => {\n    // Implementation needed\n    return {\n      success: true,\n      message: \"Content block deleted\",\n    };\n  },\n\n  // Quiz Question Services\n  getQuizQuestions: async (options: any) => {\n    try {\n      const { pagination, sectionId } = options;\n      \n      if (!sectionId) {\n        return {\n          success: false,\n          error: \"Section ID is required\",\n          data: [],\n          pagination: {\n            page: 1,\n            limit: 20,\n            total: 0,\n            totalPages: 0,\n            hasNext: false,\n            hasPrev: false,\n          },\n        };\n      }\n\n      // Get quiz questions for the section\n      const questions = await getQuizQuestionsBySectionId(sectionId, {\n        includeUnpublished: false, // Only published questions for regular users\n        sortBy: \"orderIndex\",\n        sortOrder: \"asc\",\n      });\n\n      // Calculate pagination\n      const total = questions.length;\n      const totalPages = Math.ceil(total / pagination.limit);\n      const offset = (pagination.page - 1) * pagination.limit;\n      const paginatedQuestions = questions.slice(offset, offset + pagination.limit);\n\n      return {\n        success: true,\n        data: paginatedQuestions,\n        pagination: {\n          page: pagination.page,\n          limit: pagination.limit,\n          total,\n          totalPages,\n          hasNext: pagination.page < totalPages,\n          hasPrev: pagination.page > 1,\n        },\n      };\n    } catch (error) {\n      console.error(\"Error in getQuizQuestions service:\", error);\n      return {\n        success: false,\n        error: \"Failed to fetch quiz questions\",\n        data: [],\n        pagination: {\n          page: 1,\n          limit: 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrev: false,\n        },\n      };\n    }\n  },\n\n  createQuizQuestion: async (data: any) => {\n    // Implementation needed\n    return {\n      success: true,\n      data: {},\n    };\n  },\n\n  updateQuizQuestion: async (id: string, data: any) => {\n    // Implementation needed\n    return {\n      success: true,\n      data: {},\n    };\n  },\n\n  deleteQuizQuestion: async (id: string) => {\n    // Implementation needed\n    return {\n      success: true,\n      message: \"Quiz question deleted\",\n    };\n  },\n\n  // User Progress Services\n  getUserProgress: async (options: any) => {\n    // Simple implementation for now\n    return {\n      success: true,\n      data: [],\n      pagination: {\n        page: 1,\n        limit: 20,\n        total: 0,\n        totalPages: 0,\n        hasNext: false,\n        hasPrev: false,\n      },\n    };\n  },\n\n  createUserProgress: async (data: any) => {\n    return updateUserProgressService(\"\", data);\n  },\n\n  updateUserProgress: async (id: string, data: any) => {\n    return updateUserProgressService(\"\", data);\n  },\n\n  deleteUserProgress: async (id: string) => {\n    // Implementation needed\n    return {\n      success: true,\n      message: \"User progress deleted\",\n    };\n  },\n\n  // Course Content Services\n  getCourseContent: getCourseContentService,\n  getSectionContent: getSectionContentService,\n\n  // Quiz Answer Services\n  submitQuizAnswer: submitQuizAnswerService,\n\n  // Course Completion Services\n  getCourseCompletionStatus: getCourseCompletionStatusService,\n};\n"],"names":[],"mappings":"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"}